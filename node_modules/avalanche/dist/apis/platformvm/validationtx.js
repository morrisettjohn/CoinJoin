"use strict";
/**
 * @packageDocumentation
 * @module API-PlatformVM-ValidationTx
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AddValidatorTx = exports.AddDelegatorTx = exports.WeightedValidatorTx = exports.ValidatorTx = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const bintools_1 = __importDefault(require("../../utils/bintools"));
const basetx_1 = require("./basetx");
const outputs_1 = require("../platformvm/outputs");
const buffer_1 = require("buffer/");
const constants_1 = require("./constants");
const constants_2 = require("../../utils/constants");
const helperfunctions_1 = require("../../utils/helperfunctions");
const outputs_2 = require("./outputs");
const serialization_1 = require("../../utils/serialization");
const errors_1 = require("../../utils/errors");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
const serializer = serialization_1.Serialization.getInstance();
/**
 * Abstract class representing an transactions with validation information.
 */
class ValidatorTx extends basetx_1.BaseTx {
    constructor(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime) {
        super(networkid, blockchainid, outs, ins, memo);
        this._typeName = "ValidatorTx";
        this._typeID = undefined;
        this.nodeID = buffer_1.Buffer.alloc(20);
        this.startTime = buffer_1.Buffer.alloc(8);
        this.endTime = buffer_1.Buffer.alloc(8);
        this.nodeID = nodeID;
        this.startTime = bintools.fromBNToBuffer(startTime, 8);
        this.endTime = bintools.fromBNToBuffer(endTime, 8);
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "nodeID": serializer.encoder(this.nodeID, encoding, "Buffer", "nodeID"), "startTime": serializer.encoder(this.startTime, encoding, "Buffer", "decimalString"), "endTime": serializer.encoder(this.endTime, encoding, "Buffer", "decimalString") });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.nodeID = serializer.decoder(fields["nodeID"], encoding, "nodeID", "Buffer", 20);
        this.startTime = serializer.decoder(fields["startTime"], encoding, "decimalString", "Buffer", 8);
        this.endTime = serializer.decoder(fields["endTime"], encoding, "decimalString", "Buffer", 8);
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getNodeID() {
        return this.nodeID;
    }
    /**
     * Returns a string for the nodeID amount.
     */
    getNodeIDString() {
        return helperfunctions_1.bufferToNodeIDString(this.nodeID);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getStartTime() {
        return bintools.fromBufferToBN(this.startTime);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getEndTime() {
        return bintools.fromBufferToBN(this.endTime);
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        this.nodeID = bintools.copyFrom(bytes, offset, offset + 20);
        offset += 20;
        this.startTime = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        this.endTime = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[ValidatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        const bsize = superbuff.length + this.nodeID.length + this.startTime.length + this.endTime.length;
        return buffer_1.Buffer.concat([
            superbuff,
            this.nodeID,
            this.startTime,
            this.endTime
        ], bsize);
    }
}
exports.ValidatorTx = ValidatorTx;
class WeightedValidatorTx extends ValidatorTx {
    /**
     * Class representing an unsigned AddSubnetValidatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param weight Optional. The amount of nAVAX the validator is staking.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, weight = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime);
        this._typeName = "WeightedValidatorTx";
        this._typeID = undefined;
        this.weight = buffer_1.Buffer.alloc(8);
        if (typeof weight !== undefined) {
            this.weight = bintools.fromBNToBuffer(weight, 8);
        }
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "weight": serializer.encoder(this.weight, encoding, "Buffer", "decimalString") });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.weight = serializer.decoder(fields["weight"], encoding, "decimalString", "Buffer", 8);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getWeight() {
        return bintools.fromBufferToBN(this.weight);
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getWeightBuffer() {
        return this.weight;
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        this.weight = bintools.copyFrom(bytes, offset, offset + 8);
        offset += 8;
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[AddSubnetValidatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        return buffer_1.Buffer.concat([superbuff, this.weight]);
    }
}
exports.WeightedValidatorTx = WeightedValidatorTx;
/* Must implement later, the signing process isn't friendly to AvalancheJS

export class AddSubnetValidatorTx extends WeightedValidatorTx {
    protected subnetID:Buffer = Buffer.alloc(32);
    protected subnetAddrs:Array<Buffer> = [];
    protected subnetAuthIdxs:Array<Buffer> = [];


    getTxType = ():number => {
        return PlatformVMConstants.ADDSUBNETVALIDATORTX;
    }


    getSubnetID = ():Buffer => {
        return this.subnetID;
    }


    getSubnetIDString = ():string => {
        return bintools.cb58Encode(this.subnetID);
    }


    getSubnetAuthAddresses = ():Array<Buffer> => {
        return this.subnetAddrs;
    }


    setSubnetAuthAddresses = (addrs:Array<Buffer>):void => {
        this.subnetAddrs = addrs;
    }

    calcSubnetAuthIdxs = (addrs:Array<Buffer>):Array<Buffer> => {
        let idxs:Array<Buffer> = [];
        addrs = addrs.sort();
        for(let i = 0; i < addrs.length; i++){
            let idx:Buffer = Buffer.alloc(4);
            idx.writeUInt32BE(i,0);
            idxs.push(idx);
        }
    }


    getSubnetAuthIdxs = ():Array<Buffer> => {
        return this.subnetAddrs;
    }

    fromBuffer(bytes:Buffer, offset:number = 0):number {
        offset = super.fromBuffer(bytes, offset);
        this.subnetID = bintools.copyFrom(bytes, offset, offset + 32);
        offset += 32;
        let sublenbuff:Buffer = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        let sublen:number = sublenbuff.readUInt32BE(0);
        for(let i = 0; i < sublen; i++){

        }
        offset = this.subnetAuth.fromBuffer(bytes, offset);
        return offset;
    }


    toBuffer():Buffer {
        const superbuff:Buffer = super.toBuffer();

        return Buffer.concat([superbuff, this.subnetID, subAuth], superbuff.length + this.subnetID.length + subAuth.length);
    }


    sign(msg:Buffer, kc:KeyChain):Array<Credential> {
        let creds:Array<SECPCredential> = super.sign(msg, kc);
        const cred:SECPCredential = SelectCredentialClass(PlatformVMConstants.SECPCREDENTIAL) as SECPCredential;
        for(let i = 0; i  < this.subnetAuth.length ; i++) {
            if(!kc.hasKey(this.subnetAuth[i])) {
                throw new Error("AddSubnetValidatorTx.sign -- specified address in subnetAuth not existent in provided keychain.");
            }
            
            let kp:KeyPair = kc.getKey(this.subnetAuth[i]);
            const signval:Buffer = kp.sign(msg);
            const sig:Signature = new Signature();
            sig.fromBuffer(signval);
            cred.addSignature(sig);
        }
        creds.push(cred);
        return creds;
    }


    constructor(
        networkid:number = DefaultNetworkID,
        blockchainid:Buffer = Buffer.alloc(32, 16),
        outs:Array<TransferableOutput> = undefined,
        ins:Array<TransferableInput> = undefined,
        memo:Buffer = undefined,
        nodeID:Buffer = undefined,
        startTime:BN = undefined,
        endTime:BN = undefined,
        weight:BN = undefined,
        subnetID:Buffer = undefined,
        subnetAuth:Array<Buffer> = undefined
    ) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, weight);
        if(typeof subnetID !== undefined){
            this.subnetID = subnetID;
        }
        if(typeof subnetAuth !== undefined) {
            this.subnetAuth = subnetAuth;
        }
    }

}
*/
/**
 * Class representing an unsigned AddDelegatorTx transaction.
 */
class AddDelegatorTx extends WeightedValidatorTx {
    /**
     * Class representing an unsigned AddDelegatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param stakeAmount Optional. The amount of nAVAX the validator is staking.
     * @param stakeOuts Optional. The outputs used in paying the stake.
     * @param rewardOwners Optional. The [[ParseableOutput]] containing a [[SECPOwnerOutput]] for the rewards.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, stakeAmount = undefined, stakeOuts = undefined, rewardOwners = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, stakeAmount);
        this._typeName = "AddDelegatorTx";
        this._typeID = constants_1.PlatformVMConstants.ADDDELEGATORTX;
        this.stakeOuts = [];
        this.rewardOwners = undefined;
        /**
           * Returns the id of the [[AddDelegatorTx]]
           */
        this.getTxType = () => {
            return this._typeID;
        };
        if (typeof stakeOuts !== undefined) {
            this.stakeOuts = stakeOuts;
        }
        this.rewardOwners = rewardOwners;
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "stakeOuts": this.stakeOuts.map((s) => s.serialize(encoding)), "rewardOwners": this.rewardOwners.serialize(encoding) });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.stakeOuts = fields["stakeOuts"].map((s) => {
            let xferout = new outputs_1.TransferableOutput();
            xferout.deserialize(s, encoding);
            return xferout;
        });
        this.rewardOwners = new outputs_2.ParseableOutput();
        this.rewardOwners.deserialize(fields["rewardOwners"], encoding);
    }
    /**
     * Returns a {@link https://github.com/indutny/bn.js/|BN} for the stake amount.
     */
    getStakeAmount() {
        return this.getWeight();
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the stake amount.
     */
    getStakeAmountBuffer() {
        return this.weight;
    }
    /**
     * Returns the array of outputs being staked.
     */
    getStakeOuts() {
        return this.stakeOuts;
    }
    /**
     * Should match stakeAmount. Used in sanity checking.
     */
    getStakeOutsTotal() {
        let val = new bn_js_1.default(0);
        for (let i = 0; i < this.stakeOuts.length; i++) {
            val = val.add(this.stakeOuts[i].getOutput().getAmount());
        }
        return val;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} for the reward address.
     */
    getRewardOwners() {
        return this.rewardOwners;
    }
    getTotalOuts() {
        return [...this.getOuts(), ...this.getStakeOuts()];
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        const numstakeouts = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        const outcount = numstakeouts.readUInt32BE(0);
        this.stakeOuts = [];
        for (let i = 0; i < outcount; i++) {
            const xferout = new outputs_1.TransferableOutput();
            offset = xferout.fromBuffer(bytes, offset);
            this.stakeOuts.push(xferout);
        }
        this.rewardOwners = new outputs_2.ParseableOutput();
        offset = this.rewardOwners.fromBuffer(bytes, offset);
        return offset;
    }
    /**
     * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[AddDelegatorTx]].
     */
    toBuffer() {
        const superbuff = super.toBuffer();
        let bsize = superbuff.length;
        const numouts = buffer_1.Buffer.alloc(4);
        numouts.writeUInt32BE(this.stakeOuts.length, 0);
        let barr = [super.toBuffer(), numouts];
        bsize += numouts.length;
        this.stakeOuts = this.stakeOuts.sort(outputs_1.TransferableOutput.comparator());
        for (let i = 0; i < this.stakeOuts.length; i++) {
            let out = this.stakeOuts[i].toBuffer();
            barr.push(out);
            bsize += out.length;
        }
        let ro = this.rewardOwners.toBuffer();
        barr.push(ro);
        bsize += ro.length;
        return buffer_1.Buffer.concat(barr, bsize);
    }
    clone() {
        let newbase = new AddDelegatorTx();
        newbase.fromBuffer(this.toBuffer());
        return newbase;
    }
    create(...args) {
        return new AddDelegatorTx(...args);
    }
}
exports.AddDelegatorTx = AddDelegatorTx;
class AddValidatorTx extends AddDelegatorTx {
    /**
     * Class representing an unsigned AddValidatorTx transaction.
     *
     * @param networkid Optional. Networkid, [[DefaultNetworkID]]
     * @param blockchainid Optional. Blockchainid, default Buffer.alloc(32, 16)
     * @param outs Optional. Array of the [[TransferableOutput]]s
     * @param ins Optional. Array of the [[TransferableInput]]s
     * @param memo Optional. {@link https://github.com/feross/buffer|Buffer} for the memo field
     * @param nodeID Optional. The node ID of the validator being added.
     * @param startTime Optional. The Unix time when the validator starts validating the Primary Network.
     * @param endTime Optional. The Unix time when the validator stops validating the Primary Network (and staked AVAX is returned).
     * @param stakeAmount Optional. The amount of nAVAX the validator is staking.
     * @param stakeOuts Optional. The outputs used in paying the stake.
     * @param rewardOwners Optional. The [[ParseableOutput]] containing the [[SECPOwnerOutput]] for the rewards.
     * @param delegationFee Optional. The percent fee this validator charges when others delegate stake to them.
     * Up to 4 decimal places allowed; additional decimal places are ignored. Must be between 0 and 100, inclusive.
     * For example, if delegationFeeRate is 1.2345 and someone delegates to this validator, then when the delegation
     * period is over, 1.2345% of the reward goes to the validator and the rest goes to the delegator.
     */
    constructor(networkid = constants_2.DefaultNetworkID, blockchainid = buffer_1.Buffer.alloc(32, 16), outs = undefined, ins = undefined, memo = undefined, nodeID = undefined, startTime = undefined, endTime = undefined, stakeAmount = undefined, stakeOuts = undefined, rewardOwners = undefined, delegationFee = undefined) {
        super(networkid, blockchainid, outs, ins, memo, nodeID, startTime, endTime, stakeAmount, stakeOuts, rewardOwners);
        this._typeName = "AddValidatorTx";
        this._typeID = constants_1.PlatformVMConstants.ADDVALIDATORTX;
        this.delegationFee = 0;
        /**
           * Returns the id of the [[AddValidatorTx]]
           */
        this.getTxType = () => {
            return this._typeID;
        };
        if (typeof delegationFee === "number") {
            if (delegationFee >= 0 && delegationFee <= 100) {
                this.delegationFee = parseFloat(delegationFee.toFixed(4));
            }
            else {
                throw new errors_1.DelegationFeeError("AddValidatorTx.constructor -- delegationFee must be in the range of 0 and 100, inclusively.");
            }
        }
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "delegationFee": serializer.encoder(this.getDelegationFeeBuffer(), encoding, "Buffer", "decimalString", 4) });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        let dbuff = serializer.decoder(fields["delegationFee"], encoding, "decimalString", "Buffer", 4);
        this.delegationFee = dbuff.readUInt32BE(0) / AddValidatorTx.delegatorMultiplier;
    }
    /**
     * Returns the delegation fee (represents a percentage from 0 to 100);
     */
    getDelegationFee() {
        return this.delegationFee;
    }
    /**
     * Returns the binary representation of the delegation fee as a {@link https://github.com/feross/buffer|Buffer}.
     */
    getDelegationFeeBuffer() {
        let dBuff = buffer_1.Buffer.alloc(4);
        let buffnum = parseFloat(this.delegationFee.toFixed(4)) * AddValidatorTx.delegatorMultiplier;
        dBuff.writeUInt32BE(buffnum, 0);
        return dBuff;
    }
    fromBuffer(bytes, offset = 0) {
        offset = super.fromBuffer(bytes, offset);
        let dbuff = bintools.copyFrom(bytes, offset, offset + 4);
        offset += 4;
        this.delegationFee = dbuff.readUInt32BE(0) / AddValidatorTx.delegatorMultiplier;
        return offset;
    }
    toBuffer() {
        let superBuff = super.toBuffer();
        let feeBuff = this.getDelegationFeeBuffer();
        return buffer_1.Buffer.concat([superBuff, feeBuff]);
    }
}
exports.AddValidatorTx = AddValidatorTx;
AddValidatorTx.delegatorMultiplier = 10000;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFsaWRhdGlvbnR4LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2FwaXMvcGxhdGZvcm12bS92YWxpZGF0aW9udHgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7Ozs7O0FBRUgsa0RBQXVCO0FBQ3ZCLG9FQUE0QztBQUM1QyxxQ0FBa0M7QUFDbEMsbURBQTJEO0FBRTNELG9DQUFpQztBQUNqQywyQ0FBa0Q7QUFDbEQscURBQXlEO0FBQ3pELGlFQUFtRTtBQUNuRSx1Q0FBMEQ7QUFDMUQsNkRBQThFO0FBQzlFLCtDQUF3RDtBQUV4RDs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFHLGtCQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDeEMsTUFBTSxVQUFVLEdBQUcsNkJBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUUvQzs7R0FFRztBQUNILE1BQXNCLFdBQVksU0FBUSxlQUFNO0lBNEU1QyxZQUNJLFNBQWdCLEVBQ2hCLFlBQW1CLEVBQ25CLElBQThCLEVBQzlCLEdBQTRCLEVBQzVCLElBQVksRUFDWixNQUFjLEVBQ2QsU0FBYSxFQUNiLE9BQVc7UUFFWCxLQUFLLENBQUMsU0FBUyxFQUFFLFlBQVksRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBckYxQyxjQUFTLEdBQUcsYUFBYSxDQUFDO1FBQzFCLFlBQU8sR0FBRyxTQUFTLENBQUM7UUFrQnBCLFdBQU0sR0FBVSxlQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2pDLGNBQVMsR0FBVSxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ25DLFlBQU8sR0FBVSxlQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBaUV2QyxJQUFJLENBQUMsTUFBTSxHQUFHLE1BQU0sQ0FBQztRQUNyQixJQUFJLENBQUMsU0FBUyxHQUFHLFFBQVEsQ0FBQyxjQUFjLENBQUMsU0FB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R0FBVSxLQUFLLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBBUEktUGxhdGZvcm1WTS1WYWxpZGF0aW9uVHhcbiAqL1xuXG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IEJpblRvb2xzIGZyb20gJy4uLy4uL3V0aWxzL2JpbnRvb2xzJztcbmltcG9ydCB7IEJhc2VUeCB9IGZyb20gJy4vYmFzZXR4JztcbmltcG9ydCB7IFRyYW5zZmVyYWJsZU91dHB1dCB9IGZyb20gJy4uL3BsYXRmb3Jtdm0vb3V0cHV0cyc7XG5pbXBvcnQgeyBUcmFuc2ZlcmFibGVJbnB1dCB9IGZyb20gJy4uL3BsYXRmb3Jtdm0vaW5wdXRzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlci8nO1xuaW1wb3J0IHsgUGxhdGZvcm1WTUNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IERlZmF1bHROZXR3b3JrSUQgfSBmcm9tICcuLi8uLi91dGlscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgYnVmZmVyVG9Ob2RlSURTdHJpbmcgfSBmcm9tICcuLi8uLi91dGlscy9oZWxwZXJmdW5jdGlvbnMnO1xuaW1wb3J0IHsgQW1vdW50T3V0cHV0LCBQYXJzZWFibGVPdXRwdXQgfSBmcm9tICcuL291dHB1dHMnO1xuaW1wb3J0IHsgU2VyaWFsaXphdGlvbiwgU2VyaWFsaXplZEVuY29kaW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvc2VyaWFsaXphdGlvbic7XG5pbXBvcnQgeyBEZWxlZ2F0aW9uRmVlRXJyb3IgfSBmcm9tICcuLi8uLi91dGlscy9lcnJvcnMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuY29uc3Qgc2VyaWFsaXplciA9IFNlcmlhbGl6YXRpb24uZ2V0SW5zdGFuY2UoKTtcblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyByZXByZXNlbnRpbmcgYW4gdHJhbnNhY3Rpb25zIHdpdGggdmFsaWRhdGlvbiBpbmZvcm1hdGlvbi5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFZhbGlkYXRvclR4IGV4dGVuZHMgQmFzZVR4IHtcbiAgICBwcm90ZWN0ZWQgX3R5cGVOYW1lID0gXCJWYWxpZGF0b3JUeFwiO1xuICAgIHByb3RlY3RlZCBfdHlwZUlEID0gdW5kZWZpbmVkO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIFwibm9kZUlEXCI6c2VyaWFsaXplci5lbmNvZGVyKHRoaXMubm9kZUlELCBlbmNvZGluZywgXCJCdWZmZXJcIiwgXCJub2RlSURcIiksXG4gICAgICAgICAgICBcInN0YXJ0VGltZVwiOnNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLnN0YXJ0VGltZSwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiKSxcbiAgICAgICAgICAgIFwiZW5kVGltZVwiOnNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLmVuZFRpbWUsIGVuY29kaW5nLCBcIkJ1ZmZlclwiLCBcImRlY2ltYWxTdHJpbmdcIilcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGVzZXJpYWxpemUoZmllbGRzOm9iamVjdCwgZW5jb2Rpbmc6U2VyaWFsaXplZEVuY29kaW5nID0gXCJoZXhcIikge1xuICAgICAgICBzdXBlci5kZXNlcmlhbGl6ZShmaWVsZHMsIGVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5ub2RlSUQgPSBzZXJpYWxpemVyLmRlY29kZXIoZmllbGRzW1wibm9kZUlEXCJdLCBlbmNvZGluZywgXCJub2RlSURcIiwgXCJCdWZmZXJcIiwgMjApO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJzdGFydFRpbWVcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgOCk7XG4gICAgICAgIHRoaXMuZW5kVGltZSA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJlbmRUaW1lXCJdLCBlbmNvZGluZywgXCJkZWNpbWFsU3RyaW5nXCIsIFwiQnVmZmVyXCIsIDgpO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBub2RlSUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDIwKTtcbiAgICBwcm90ZWN0ZWQgc3RhcnRUaW1lOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg4KTtcbiAgICBwcm90ZWN0ZWQgZW5kVGltZTpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0Tm9kZUlEKCk6QnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZUlEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgZm9yIHRoZSBub2RlSUQgYW1vdW50LlxuICAgICAqL1xuICAgIGdldE5vZGVJRFN0cmluZygpOnN0cmluZyB7XG4gICAgICAgIHJldHVybiBidWZmZXJUb05vZGVJRFN0cmluZyh0aGlzLm5vZGVJRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRTdGFydFRpbWUoKXtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuc3RhcnRUaW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0RW5kVGltZSgpIHtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmZyb21CdWZmZXJUb0JOKHRoaXMuZW5kVGltZSk7XG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLm5vZGVJRCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDIwKTtcbiAgICAgICAgb2Zmc2V0ICs9IDIwO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgdGhpcy5lbmRUaW1lID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgOCk7XG4gICAgICAgIG9mZnNldCArPSA4O1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tWYWxpZGF0b3JUeF1dLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgY29uc3Qgc3VwZXJidWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGJzaXplOm51bWJlciA9IHN1cGVyYnVmZi5sZW5ndGggKyB0aGlzLm5vZGVJRC5sZW5ndGggKyB0aGlzLnN0YXJ0VGltZS5sZW5ndGggKyB0aGlzLmVuZFRpbWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBzdXBlcmJ1ZmYsXG4gICAgICAgICAgICB0aGlzLm5vZGVJRCxcbiAgICAgICAgICAgIHRoaXMuc3RhcnRUaW1lLFxuICAgICAgICAgICAgdGhpcy5lbmRUaW1lXG4gICAgICAgIF0sIGJzaXplKTtcbiAgICB9XG4gICAgXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG5ldHdvcmtpZDpudW1iZXIsIFxuICAgICAgICBibG9ja2NoYWluaWQ6QnVmZmVyLCBcbiAgICAgICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+LCBcbiAgICAgICAgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiwgXG4gICAgICAgIG1lbW8/OkJ1ZmZlciwgXG4gICAgICAgIG5vZGVJRD86QnVmZmVyLCBcbiAgICAgICAgc3RhcnRUaW1lPzpCTiwgXG4gICAgICAgIGVuZFRpbWU/OkJOXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8pO1xuICAgICAgICB0aGlzLm5vZGVJRCA9IG5vZGVJRDtcbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcihzdGFydFRpbWUsIDgpO1xuICAgICAgICB0aGlzLmVuZFRpbWUgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcihlbmRUaW1lLCA4KTtcbiAgICB9XG5cbn1cblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFdlaWdodGVkVmFsaWRhdG9yVHggZXh0ZW5kcyBWYWxpZGF0b3JUeCB7XG4gICAgcHJvdGVjdGVkIF90eXBlTmFtZSA9IFwiV2VpZ2h0ZWRWYWxpZGF0b3JUeFwiO1xuICAgIHByb3RlY3RlZCBfdHlwZUlEID0gdW5kZWZpbmVkO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpZWxkcyxcbiAgICAgICAgICAgIFwid2VpZ2h0XCI6IHNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLndlaWdodCwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiKVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXNlcmlhbGl6ZShmaWVsZHM6b2JqZWN0LCBlbmNvZGluZzpTZXJpYWxpemVkRW5jb2RpbmcgPSBcImhleFwiKSB7XG4gICAgICAgIHN1cGVyLmRlc2VyaWFsaXplKGZpZWxkcywgZW5jb2RpbmcpO1xuICAgICAgICB0aGlzLndlaWdodCA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJ3ZWlnaHRcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgOCk7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIHdlaWdodDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoOCk7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0gZm9yIHRoZSBzdGFrZSBhbW91bnQuXG4gICAgICovXG4gICAgZ2V0V2VpZ2h0KCk6Qk4ge1xuICAgICAgICByZXR1cm4gYmludG9vbHMuZnJvbUJ1ZmZlclRvQk4odGhpcy53ZWlnaHQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRXZWlnaHRCdWZmZXIoKTpCdWZmZXIge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWlnaHQ7XG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLndlaWdodCA9IGJpbnRvb2xzLmNvcHlGcm9tKGJ5dGVzLCBvZmZzZXQsIG9mZnNldCArIDgpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbQWRkU3VibmV0VmFsaWRhdG9yVHhdXS5cbiAgICAgKi9cbiAgICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgICAgIGNvbnN0IHN1cGVyYnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbc3VwZXJidWZmLCB0aGlzLndlaWdodF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBBZGRTdWJuZXRWYWxpZGF0b3JUeCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JraWQgT3B0aW9uYWwuIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIE9wdGlvbmFsLiBCbG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXNcbiAgICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbC4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG5vZGVJRCBPcHRpb25hbC4gVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdGFydHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdG9wcyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsgKGFuZCBzdGFrZWQgQVZBWCBpcyByZXR1cm5lZCkuXG4gICAgICogQHBhcmFtIHdlaWdodCBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBuQVZBWCB0aGUgdmFsaWRhdG9yIGlzIHN0YWtpbmcuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG5ldHdvcmtpZDpudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELCBcbiAgICAgICAgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLCBcbiAgICAgICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLCBcbiAgICAgICAgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBcbiAgICAgICAgbm9kZUlEOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIHN0YXJ0VGltZTpCTiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGVuZFRpbWU6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHdlaWdodDpCTiA9IHVuZGVmaW5lZCxcbiAgICApIHtcbiAgICAgICAgc3VwZXIobmV0d29ya2lkLCBibG9ja2NoYWluaWQsIG91dHMsIGlucywgbWVtbywgbm9kZUlELCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgICAgICBpZih0eXBlb2Ygd2VpZ2h0ICE9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgdGhpcy53ZWlnaHQgPSBiaW50b29scy5mcm9tQk5Ub0J1ZmZlcih3ZWlnaHQsIDgpO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4vKiBNdXN0IGltcGxlbWVudCBsYXRlciwgdGhlIHNpZ25pbmcgcHJvY2VzcyBpc24ndCBmcmllbmRseSB0byBBdmFsYW5jaGVKU1xuXG5leHBvcnQgY2xhc3MgQWRkU3VibmV0VmFsaWRhdG9yVHggZXh0ZW5kcyBXZWlnaHRlZFZhbGlkYXRvclR4IHtcbiAgICBwcm90ZWN0ZWQgc3VibmV0SUQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgICBwcm90ZWN0ZWQgc3VibmV0QWRkcnM6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgIHByb3RlY3RlZCBzdWJuZXRBdXRoSWR4czpBcnJheTxCdWZmZXI+ID0gW107XG5cblxuICAgIGdldFR4VHlwZSA9ICgpOm51bWJlciA9PiB7XG4gICAgICAgIHJldHVybiBQbGF0Zm9ybVZNQ29uc3RhbnRzLkFERFNVQk5FVFZBTElEQVRPUlRYO1xuICAgIH1cblxuXG4gICAgZ2V0U3VibmV0SUQgPSAoKTpCdWZmZXIgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJuZXRJRDtcbiAgICB9XG5cblxuICAgIGdldFN1Ym5ldElEU3RyaW5nID0gKCk6c3RyaW5nID0+IHtcbiAgICAgICAgcmV0dXJuIGJpbnRvb2xzLmNiNThFbmNvZGUodGhpcy5zdWJuZXRJRCk7XG4gICAgfVxuXG5cbiAgICBnZXRTdWJuZXRBdXRoQWRkcmVzc2VzID0gKCk6QXJyYXk8QnVmZmVyPiA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1Ym5ldEFkZHJzO1xuICAgIH1cblxuXG4gICAgc2V0U3VibmV0QXV0aEFkZHJlc3NlcyA9IChhZGRyczpBcnJheTxCdWZmZXI+KTp2b2lkID0+IHtcbiAgICAgICAgdGhpcy5zdWJuZXRBZGRycyA9IGFkZHJzO1xuICAgIH1cblxuICAgIGNhbGNTdWJuZXRBdXRoSWR4cyA9IChhZGRyczpBcnJheTxCdWZmZXI+KTpBcnJheTxCdWZmZXI+ID0+IHtcbiAgICAgICAgbGV0IGlkeHM6QXJyYXk8QnVmZmVyPiA9IFtdO1xuICAgICAgICBhZGRycyA9IGFkZHJzLnNvcnQoKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IGFkZHJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGxldCBpZHg6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgICAgaWR4LndyaXRlVUludDMyQkUoaSwwKTtcbiAgICAgICAgICAgIGlkeHMucHVzaChpZHgpO1xuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICBnZXRTdWJuZXRBdXRoSWR4cyA9ICgpOkFycmF5PEJ1ZmZlcj4gPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJuZXRBZGRycztcbiAgICB9XG5cbiAgICBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0Om51bWJlciA9IDApOm51bWJlciB7XG4gICAgICAgIG9mZnNldCA9IHN1cGVyLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuc3VibmV0SUQgPSBiaW50b29scy5jb3B5RnJvbShieXRlcywgb2Zmc2V0LCBvZmZzZXQgKyAzMik7XG4gICAgICAgIG9mZnNldCArPSAzMjtcbiAgICAgICAgbGV0IHN1YmxlbmJ1ZmY6QnVmZmVyID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBsZXQgc3VibGVuOm51bWJlciA9IHN1YmxlbmJ1ZmYucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc3VibGVuOyBpKyspe1xuXG4gICAgICAgIH1cbiAgICAgICAgb2Zmc2V0ID0gdGhpcy5zdWJuZXRBdXRoLmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgfVxuXG5cbiAgICB0b0J1ZmZlcigpOkJ1ZmZlciB7XG4gICAgICAgIGNvbnN0IHN1cGVyYnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuXG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtzdXBlcmJ1ZmYsIHRoaXMuc3VibmV0SUQsIHN1YkF1dGhdLCBzdXBlcmJ1ZmYubGVuZ3RoICsgdGhpcy5zdWJuZXRJRC5sZW5ndGggKyBzdWJBdXRoLmxlbmd0aCk7XG4gICAgfVxuXG5cbiAgICBzaWduKG1zZzpCdWZmZXIsIGtjOktleUNoYWluKTpBcnJheTxDcmVkZW50aWFsPiB7XG4gICAgICAgIGxldCBjcmVkczpBcnJheTxTRUNQQ3JlZGVudGlhbD4gPSBzdXBlci5zaWduKG1zZywga2MpO1xuICAgICAgICBjb25zdCBjcmVkOlNFQ1BDcmVkZW50aWFsID0gU2VsZWN0Q3JlZGVudGlhbENsYXNzKFBsYXRmb3JtVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUwpIGFzIFNFQ1BDcmVkZW50aWFsO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpICA8IHRoaXMuc3VibmV0QXV0aC5sZW5ndGggOyBpKyspIHtcbiAgICAgICAgICAgIGlmKCFrYy5oYXNLZXkodGhpcy5zdWJuZXRBdXRoW2ldKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFkZFN1Ym5ldFZhbGlkYXRvclR4LnNpZ24gLS0gc3BlY2lmaWVkIGFkZHJlc3MgaW4gc3VibmV0QXV0aCBub3QgZXhpc3RlbnQgaW4gcHJvdmlkZWQga2V5Y2hhaW4uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsZXQga3A6S2V5UGFpciA9IGtjLmdldEtleSh0aGlzLnN1Ym5ldEF1dGhbaV0pO1xuICAgICAgICAgICAgY29uc3Qgc2lnbnZhbDpCdWZmZXIgPSBrcC5zaWduKG1zZyk7XG4gICAgICAgICAgICBjb25zdCBzaWc6U2lnbmF0dXJlID0gbmV3IFNpZ25hdHVyZSgpO1xuICAgICAgICAgICAgc2lnLmZyb21CdWZmZXIoc2lnbnZhbCk7XG4gICAgICAgICAgICBjcmVkLmFkZFNpZ25hdHVyZShzaWcpO1xuICAgICAgICB9XG4gICAgICAgIGNyZWRzLnB1c2goY3JlZCk7XG4gICAgICAgIHJldHVybiBjcmVkcztcbiAgICB9XG5cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBuZXR3b3JraWQ6bnVtYmVyID0gRGVmYXVsdE5ldHdvcmtJRCwgXG4gICAgICAgIGJsb2NrY2hhaW5pZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIsIDE2KSwgXG4gICAgICAgIG91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGluczpBcnJheTxUcmFuc2ZlcmFibGVJbnB1dD4gPSB1bmRlZmluZWQsIFxuICAgICAgICBtZW1vOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG5vZGVJRDpCdWZmZXIgPSB1bmRlZmluZWQsIFxuICAgICAgICBzdGFydFRpbWU6Qk4gPSB1bmRlZmluZWQsIFxuICAgICAgICBlbmRUaW1lOkJOID0gdW5kZWZpbmVkLFxuICAgICAgICB3ZWlnaHQ6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHN1Ym5ldElEOkJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3VibmV0QXV0aDpBcnJheTxCdWZmZXI+ID0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8sIG5vZGVJRCwgc3RhcnRUaW1lLCBlbmRUaW1lLCB3ZWlnaHQpO1xuICAgICAgICBpZih0eXBlb2Ygc3VibmV0SUQgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnN1Ym5ldElEID0gc3VibmV0SUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYodHlwZW9mIHN1Ym5ldEF1dGggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5zdWJuZXRBdXRoID0gc3VibmV0QXV0aDtcbiAgICAgICAgfVxuICAgIH1cblxufVxuKi9cblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgQWRkRGVsZWdhdG9yVHggdHJhbnNhY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBBZGREZWxlZ2F0b3JUeCBleHRlbmRzIFdlaWdodGVkVmFsaWRhdG9yVHgge1xuICAgIHByb3RlY3RlZCBfdHlwZU5hbWUgPSBcIkFkZERlbGVnYXRvclR4XCI7XG4gICAgcHJvdGVjdGVkIF90eXBlSUQgPSBQbGF0Zm9ybVZNQ29uc3RhbnRzLkFERERFTEVHQVRPUlRYO1xuXG4gICAgc2VyaWFsaXplKGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpOm9iamVjdCB7XG4gICAgICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICAgICAgcmV0dXJuICB7XG4gICAgICAgICAgICAuLi5maWVsZHMsXG4gICAgICAgICAgICBcInN0YWtlT3V0c1wiOiB0aGlzLnN0YWtlT3V0cy5tYXAoKHMpID0+IHMuc2VyaWFsaXplKGVuY29kaW5nKSksXG4gICAgICAgICAgICBcInJld2FyZE93bmVyc1wiOiB0aGlzLnJld2FyZE93bmVycy5zZXJpYWxpemUoZW5jb2RpbmcpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRlc2VyaWFsaXplKGZpZWxkczpvYmplY3QsIGVuY29kaW5nOlNlcmlhbGl6ZWRFbmNvZGluZyA9IFwiaGV4XCIpIHtcbiAgICAgICAgc3VwZXIuZGVzZXJpYWxpemUoZmllbGRzLCBlbmNvZGluZyk7XG4gICAgICAgIHRoaXMuc3Rha2VPdXRzID0gZmllbGRzW1wic3Rha2VPdXRzXCJdLm1hcCgoczpvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCB4ZmVyb3V0OlRyYW5zZmVyYWJsZU91dHB1dCA9IG5ldyBUcmFuc2ZlcmFibGVPdXRwdXQoKTtcbiAgICAgICAgICAgIHhmZXJvdXQuZGVzZXJpYWxpemUocywgZW5jb2RpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHhmZXJvdXQ7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnJld2FyZE93bmVycyA9IG5ldyBQYXJzZWFibGVPdXRwdXQoKTtcbiAgICAgICAgdGhpcy5yZXdhcmRPd25lcnMuZGVzZXJpYWxpemUoZmllbGRzW1wicmV3YXJkT3duZXJzXCJdLCBlbmNvZGluZyk7XG4gICAgfVxuICAgIFxuICAgIHByb3RlY3RlZCBzdGFrZU91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IFtdO1xuICAgIHByb3RlY3RlZCByZXdhcmRPd25lcnM6UGFyc2VhYmxlT3V0cHV0ID0gdW5kZWZpbmVkO1xuICBcbiAgICAvKipcbiAgICAgICAqIFJldHVybnMgdGhlIGlkIG9mIHRoZSBbW0FkZERlbGVnYXRvclR4XV1cbiAgICAgICAqL1xuICAgIGdldFR4VHlwZSA9ICgpOm51bWJlciA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5fdHlwZUlEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBmb3IgdGhlIHN0YWtlIGFtb3VudC5cbiAgICAgKi9cbiAgICBnZXRTdGFrZUFtb3VudCgpOkJOIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0V2VpZ2h0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgc3Rha2UgYW1vdW50LlxuICAgICAqL1xuICAgIGdldFN0YWtlQW1vdW50QnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2VpZ2h0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFycmF5IG9mIG91dHB1dHMgYmVpbmcgc3Rha2VkLlxuICAgICAqL1xuICAgIGdldFN0YWtlT3V0cygpOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4ge1xuICAgICAgICByZXR1cm4gdGhpcy5zdGFrZU91dHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2hvdWxkIG1hdGNoIHN0YWtlQW1vdW50LiBVc2VkIGluIHNhbml0eSBjaGVja2luZy5cbiAgICAgKi9cbiAgICBnZXRTdGFrZU91dHNUb3RhbCgpOkJOIHtcbiAgICAgICAgbGV0IHZhbDpCTiA9IG5ldyBCTigwKTtcbiAgICAgICAgZm9yKGxldCBpID0gMDsgaSA8IHRoaXMuc3Rha2VPdXRzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICB2YWwgPSB2YWwuYWRkKCh0aGlzLnN0YWtlT3V0c1tpXS5nZXRPdXRwdXQoKSBhcyBBbW91bnRPdXRwdXQpLmdldEFtb3VudCgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSByZXdhcmQgYWRkcmVzcy5cbiAgICAgKi9cbiAgICBnZXRSZXdhcmRPd25lcnMoKTpQYXJzZWFibGVPdXRwdXQge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXdhcmRPd25lcnM7XG4gICAgfVxuICAgIFxuICAgIGdldFRvdGFsT3V0cygpOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4ge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuZ2V0T3V0cygpIGFzIEFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4sIC4uLnRoaXMuZ2V0U3Rha2VPdXRzKCldO1xuICAgIH1cblxuICAgIGZyb21CdWZmZXIoYnl0ZXM6QnVmZmVyLCBvZmZzZXQ6bnVtYmVyID0gMCk6bnVtYmVyIHtcbiAgICAgICAgb2Zmc2V0ID0gc3VwZXIuZnJvbUJ1ZmZlcihieXRlcywgb2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbnVtc3Rha2VvdXRzID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICBjb25zdCBvdXRjb3VudDpudW1iZXIgPSBudW1zdGFrZW91dHMucmVhZFVJbnQzMkJFKDApO1xuICAgICAgICB0aGlzLnN0YWtlT3V0cyA9IFtdO1xuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgb3V0Y291bnQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeGZlcm91dDpUcmFuc2ZlcmFibGVPdXRwdXQgPSBuZXcgVHJhbnNmZXJhYmxlT3V0cHV0KCk7XG4gICAgICAgICAgICBvZmZzZXQgPSB4ZmVyb3V0LmZyb21CdWZmZXIoYnl0ZXMsIG9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLnN0YWtlT3V0cy5wdXNoKHhmZXJvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV3YXJkT3duZXJzID0gbmV3IFBhcnNlYWJsZU91dHB1dCgpO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLnJld2FyZE93bmVycy5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRhdGlvbiBvZiB0aGUgW1tBZGREZWxlZ2F0b3JUeF1dLlxuICAgICAqL1xuICAgIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgY29uc3Qgc3VwZXJidWZmOkJ1ZmZlciA9IHN1cGVyLnRvQnVmZmVyKCk7XG4gICAgICAgIGxldCBic2l6ZTpudW1iZXIgPSBzdXBlcmJ1ZmYubGVuZ3RoO1xuICAgICAgICBjb25zdCBudW1vdXRzOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgbnVtb3V0cy53cml0ZVVJbnQzMkJFKHRoaXMuc3Rha2VPdXRzLmxlbmd0aCwgMCk7XG4gICAgICAgIGxldCBiYXJyOkFycmF5PEJ1ZmZlcj4gPSBbc3VwZXIudG9CdWZmZXIoKSwgbnVtb3V0c107XG4gICAgICAgIGJzaXplICs9IG51bW91dHMubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0YWtlT3V0cyA9IHRoaXMuc3Rha2VPdXRzLnNvcnQoVHJhbnNmZXJhYmxlT3V0cHV0LmNvbXBhcmF0b3IoKSk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCB0aGlzLnN0YWtlT3V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IG91dDpCdWZmZXIgPSB0aGlzLnN0YWtlT3V0c1tpXS50b0J1ZmZlcigpO1xuICAgICAgICAgICAgYmFyci5wdXNoKG91dCk7XG4gICAgICAgICAgICBic2l6ZSArPSBvdXQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGxldCBybzpCdWZmZXIgPSB0aGlzLnJld2FyZE93bmVycy50b0J1ZmZlcigpO1xuICAgICAgICBiYXJyLnB1c2gocm8pO1xuICAgICAgICBic2l6ZSArPSByby5sZW5ndGg7XG4gICAgICAgIHJldHVybiBCdWZmZXIuY29uY2F0KGJhcnIsIGJzaXplKTtcbiAgICB9XG5cbiAgICBjbG9uZSgpOnRoaXMge1xuICAgICAgICBsZXQgbmV3YmFzZTpBZGREZWxlZ2F0b3JUeCA9IG5ldyBBZGREZWxlZ2F0b3JUeCgpO1xuICAgICAgICBuZXdiYXNlLmZyb21CdWZmZXIodGhpcy50b0J1ZmZlcigpKTtcbiAgICAgICAgcmV0dXJuIG5ld2Jhc2UgYXMgdGhpcztcbiAgICB9XG5cbiAgICBjcmVhdGUoLi4uYXJnczphbnlbXSk6dGhpcyB7XG4gICAgICAgIHJldHVybiBuZXcgQWRkRGVsZWdhdG9yVHgoLi4uYXJncykgYXMgdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gdW5zaWduZWQgQWRkRGVsZWdhdG9yVHggdHJhbnNhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV0d29ya2lkIE9wdGlvbmFsLiBOZXR3b3JraWQsIFtbRGVmYXVsdE5ldHdvcmtJRF1dXG4gICAgICogQHBhcmFtIGJsb2NrY2hhaW5pZCBPcHRpb25hbC4gQmxvY2tjaGFpbmlkLCBkZWZhdWx0IEJ1ZmZlci5hbGxvYygzMiwgMTYpXG4gICAgICogQHBhcmFtIG91dHMgT3B0aW9uYWwuIEFycmF5IG9mIHRoZSBbW1RyYW5zZmVyYWJsZU91dHB1dF1dc1xuICAgICAqIEBwYXJhbSBpbnMgT3B0aW9uYWwuIEFycmF5IG9mIHRoZSBbW1RyYW5zZmVyYWJsZUlucHV0XV1zXG4gICAgICogQHBhcmFtIG1lbW8gT3B0aW9uYWwuIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgbWVtbyBmaWVsZFxuICAgICAqIEBwYXJhbSBub2RlSUQgT3B0aW9uYWwuIFRoZSBub2RlIElEIG9mIHRoZSB2YWxpZGF0b3IgYmVpbmcgYWRkZWQuXG4gICAgICogQHBhcmFtIHN0YXJ0VGltZSBPcHRpb25hbC4gVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RhcnRzIHZhbGlkYXRpbmcgdGhlIFByaW1hcnkgTmV0d29yay5cbiAgICAgKiBAcGFyYW0gZW5kVGltZSBPcHRpb25hbC4gVGhlIFVuaXggdGltZSB3aGVuIHRoZSB2YWxpZGF0b3Igc3RvcHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrIChhbmQgc3Rha2VkIEFWQVggaXMgcmV0dXJuZWQpLlxuICAgICAqIEBwYXJhbSBzdGFrZUFtb3VudCBPcHRpb25hbC4gVGhlIGFtb3VudCBvZiBuQVZBWCB0aGUgdmFsaWRhdG9yIGlzIHN0YWtpbmcuXG4gICAgICogQHBhcmFtIHN0YWtlT3V0cyBPcHRpb25hbC4gVGhlIG91dHB1dHMgdXNlZCBpbiBwYXlpbmcgdGhlIHN0YWtlLlxuICAgICAqIEBwYXJhbSByZXdhcmRPd25lcnMgT3B0aW9uYWwuIFRoZSBbW1BhcnNlYWJsZU91dHB1dF1dIGNvbnRhaW5pbmcgYSBbW1NFQ1BPd25lck91dHB1dF1dIGZvciB0aGUgcmV3YXJkcy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbmV0d29ya2lkOm51bWJlciA9IERlZmF1bHROZXR3b3JrSUQsIFxuICAgICAgICBibG9ja2NoYWluaWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyLCAxNiksIFxuICAgICAgICBvdXRzOkFycmF5PFRyYW5zZmVyYWJsZU91dHB1dD4gPSB1bmRlZmluZWQsIFxuICAgICAgICBpbnM6QXJyYXk8VHJhbnNmZXJhYmxlSW5wdXQ+ID0gdW5kZWZpbmVkLCBcbiAgICAgICAgbWVtbzpCdWZmZXIgPSB1bmRlZmluZWQsIFxuICAgICAgICBub2RlSUQ6QnVmZmVyID0gdW5kZWZpbmVkLCBcbiAgICAgICAgc3RhcnRUaW1lOkJOID0gdW5kZWZpbmVkLCBcbiAgICAgICAgZW5kVGltZTpCTiA9IHVuZGVmaW5lZCxcbiAgICAgICAgc3Rha2VBbW91bnQ6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YWtlT3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLFxuICAgICAgICByZXdhcmRPd25lcnM6UGFyc2VhYmxlT3V0cHV0ID0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKG5ldHdvcmtpZCwgYmxvY2tjaGFpbmlkLCBvdXRzLCBpbnMsIG1lbW8sIG5vZGVJRCwgc3RhcnRUaW1lLCBlbmRUaW1lLCBzdGFrZUFtb3VudCk7XG4gICAgICAgIGlmKHR5cGVvZiBzdGFrZU91dHMgIT09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICB0aGlzLnN0YWtlT3V0cyA9IHN0YWtlT3V0c1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmV3YXJkT3duZXJzID0gcmV3YXJkT3duZXJzO1xuICAgIH1cbiAgfVxuXG5leHBvcnQgY2xhc3MgQWRkVmFsaWRhdG9yVHggZXh0ZW5kcyBBZGREZWxlZ2F0b3JUeCB7XG4gICAgcHJvdGVjdGVkIF90eXBlTmFtZSA9IFwiQWRkVmFsaWRhdG9yVHhcIjtcbiAgICBwcm90ZWN0ZWQgX3R5cGVJRCA9IFBsYXRmb3JtVk1Db25zdGFudHMuQUREVkFMSURBVE9SVFg7XG5cbiAgICBzZXJpYWxpemUoZW5jb2Rpbmc6U2VyaWFsaXplZEVuY29kaW5nID0gXCJoZXhcIik6b2JqZWN0IHtcbiAgICAgICAgbGV0IGZpZWxkczpvYmplY3QgPSBzdXBlci5zZXJpYWxpemUoZW5jb2RpbmcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmllbGRzLFxuICAgICAgICAgICAgXCJkZWxlZ2F0aW9uRmVlXCI6IHNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLmdldERlbGVnYXRpb25GZWVCdWZmZXIoKSwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiLCA0KVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkZXNlcmlhbGl6ZShmaWVsZHM6b2JqZWN0LCBlbmNvZGluZzpTZXJpYWxpemVkRW5jb2RpbmcgPSBcImhleFwiKSB7XG4gICAgICAgIHN1cGVyLmRlc2VyaWFsaXplKGZpZWxkcywgZW5jb2RpbmcpO1xuICAgICAgICBsZXQgZGJ1ZmY6QnVmZmVyID0gc2VyaWFsaXplci5kZWNvZGVyKGZpZWxkc1tcImRlbGVnYXRpb25GZWVcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgNCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGlvbkZlZSA9IGRidWZmLnJlYWRVSW50MzJCRSgwKSAvIEFkZFZhbGlkYXRvclR4LmRlbGVnYXRvck11bHRpcGxpZXI7XG4gICAgfVxuICBcblxuXG4gICAgcHJvdGVjdGVkIGRlbGVnYXRpb25GZWU6bnVtYmVyID0gMDtcbiAgICBwcml2YXRlIHN0YXRpYyBkZWxlZ2F0b3JNdWx0aXBsaWVyOm51bWJlciA9IDEwMDAwO1xuXG4gICAgLyoqXG4gICAgICAgKiBSZXR1cm5zIHRoZSBpZCBvZiB0aGUgW1tBZGRWYWxpZGF0b3JUeF1dXG4gICAgICAgKi9cbiAgICBnZXRUeFR5cGUgPSAoKTpudW1iZXIgPT4ge1xuICAgIHJldHVybiB0aGlzLl90eXBlSUQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGVsZWdhdGlvbiBmZWUgKHJlcHJlc2VudHMgYSBwZXJjZW50YWdlIGZyb20gMCB0byAxMDApO1xuICAgICAqL1xuICAgIGdldERlbGVnYXRpb25GZWUoKTpudW1iZXIge1xuICAgICAgICByZXR1cm4gdGhpcy5kZWxlZ2F0aW9uRmVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGJpbmFyeSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZGVsZWdhdGlvbiBmZWUgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cbiAgICAgKi9cbiAgICBnZXREZWxlZ2F0aW9uRmVlQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgbGV0IGRCdWZmOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgICAgICAgbGV0IGJ1ZmZudW06bnVtYmVyID0gcGFyc2VGbG9hdCh0aGlzLmRlbGVnYXRpb25GZWUudG9GaXhlZCg0KSkgKiBBZGRWYWxpZGF0b3JUeC5kZWxlZ2F0b3JNdWx0aXBsaWVyO1xuICAgICAgICBkQnVmZi53cml0ZVVJbnQzMkJFKGJ1ZmZudW0sIDApO1xuICAgICAgICByZXR1cm4gZEJ1ZmY7XG4gICAgfVxuXG4gICAgZnJvbUJ1ZmZlcihieXRlczpCdWZmZXIsIG9mZnNldDpudW1iZXIgPSAwKTpudW1iZXIge1xuICAgICAgICBvZmZzZXQgPSBzdXBlci5mcm9tQnVmZmVyKGJ5dGVzLCBvZmZzZXQpO1xuICAgICAgICBsZXQgZGJ1ZmY6QnVmZmVyID0gYmludG9vbHMuY29weUZyb20oYnl0ZXMsIG9mZnNldCwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIG9mZnNldCArPSA0O1xuICAgICAgICB0aGlzLmRlbGVnYXRpb25GZWUgPSBkYnVmZi5yZWFkVUludDMyQkUoMCkgLyBBZGRWYWxpZGF0b3JUeC5kZWxlZ2F0b3JNdWx0aXBsaWVyO1xuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cblxuICAgIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICAgICAgbGV0IHN1cGVyQnVmZjpCdWZmZXIgPSBzdXBlci50b0J1ZmZlcigpO1xuICAgICAgICBsZXQgZmVlQnVmZjpCdWZmZXIgPSB0aGlzLmdldERlbGVnYXRpb25GZWVCdWZmZXIoKTtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW3N1cGVyQnVmZiwgZmVlQnVmZl0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsYXNzIHJlcHJlc2VudGluZyBhbiB1bnNpZ25lZCBBZGRWYWxpZGF0b3JUeCB0cmFuc2FjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXR3b3JraWQgT3B0aW9uYWwuIE5ldHdvcmtpZCwgW1tEZWZhdWx0TmV0d29ya0lEXV1cbiAgICAgKiBAcGFyYW0gYmxvY2tjaGFpbmlkIE9wdGlvbmFsLiBCbG9ja2NoYWluaWQsIGRlZmF1bHQgQnVmZmVyLmFsbG9jKDMyLCAxNilcbiAgICAgKiBAcGFyYW0gb3V0cyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlT3V0cHV0XV1zXG4gICAgICogQHBhcmFtIGlucyBPcHRpb25hbC4gQXJyYXkgb2YgdGhlIFtbVHJhbnNmZXJhYmxlSW5wdXRdXXNcbiAgICAgKiBAcGFyYW0gbWVtbyBPcHRpb25hbC4ge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gZm9yIHRoZSBtZW1vIGZpZWxkXG4gICAgICogQHBhcmFtIG5vZGVJRCBPcHRpb25hbC4gVGhlIG5vZGUgSUQgb2YgdGhlIHZhbGlkYXRvciBiZWluZyBhZGRlZC5cbiAgICAgKiBAcGFyYW0gc3RhcnRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdGFydHMgdmFsaWRhdGluZyB0aGUgUHJpbWFyeSBOZXR3b3JrLlxuICAgICAqIEBwYXJhbSBlbmRUaW1lIE9wdGlvbmFsLiBUaGUgVW5peCB0aW1lIHdoZW4gdGhlIHZhbGlkYXRvciBzdG9wcyB2YWxpZGF0aW5nIHRoZSBQcmltYXJ5IE5ldHdvcmsgKGFuZCBzdGFrZWQgQVZBWCBpcyByZXR1cm5lZCkuXG4gICAgICogQHBhcmFtIHN0YWtlQW1vdW50IE9wdGlvbmFsLiBUaGUgYW1vdW50IG9mIG5BVkFYIHRoZSB2YWxpZGF0b3IgaXMgc3Rha2luZy5cbiAgICAgKiBAcGFyYW0gc3Rha2VPdXRzIE9wdGlvbmFsLiBUaGUgb3V0cHV0cyB1c2VkIGluIHBheWluZyB0aGUgc3Rha2UuXG4gICAgICogQHBhcmFtIHJld2FyZE93bmVycyBPcHRpb25hbC4gVGhlIFtbUGFyc2VhYmxlT3V0cHV0XV0gY29udGFpbmluZyB0aGUgW1tTRUNQT3duZXJPdXRwdXRdXSBmb3IgdGhlIHJld2FyZHMuXG4gICAgICogQHBhcmFtIGRlbGVnYXRpb25GZWUgT3B0aW9uYWwuIFRoZSBwZXJjZW50IGZlZSB0aGlzIHZhbGlkYXRvciBjaGFyZ2VzIHdoZW4gb3RoZXJzIGRlbGVnYXRlIHN0YWtlIHRvIHRoZW0uIFxuICAgICAqIFVwIHRvIDQgZGVjaW1hbCBwbGFjZXMgYWxsb3dlZDsgYWRkaXRpb25hbCBkZWNpbWFsIHBsYWNlcyBhcmUgaWdub3JlZC4gTXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDEwMCwgaW5jbHVzaXZlLiBcbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgZGVsZWdhdGlvbkZlZVJhdGUgaXMgMS4yMzQ1IGFuZCBzb21lb25lIGRlbGVnYXRlcyB0byB0aGlzIHZhbGlkYXRvciwgdGhlbiB3aGVuIHRoZSBkZWxlZ2F0aW9uIFxuICAgICAqIHBlcmlvZCBpcyBvdmVyLCAxLjIzNDUlIG9mIHRoZSByZXdhcmQgZ29lcyB0byB0aGUgdmFsaWRhdG9yIGFuZCB0aGUgcmVzdCBnb2VzIHRvIHRoZSBkZWxlZ2F0b3IuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIG5ldHdvcmtpZDpudW1iZXIgPSBEZWZhdWx0TmV0d29ya0lELCBcbiAgICAgICAgYmxvY2tjaGFpbmlkOkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygzMiwgMTYpLCBcbiAgICAgICAgb3V0czpBcnJheTxUcmFuc2ZlcmFibGVPdXRwdXQ+ID0gdW5kZWZpbmVkLCBcbiAgICAgICAgaW5zOkFycmF5PFRyYW5zZmVyYWJsZUlucHV0PiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIG1lbW86QnVmZmVyID0gdW5kZWZpbmVkLCBcbiAgICAgICAgbm9kZUlEOkJ1ZmZlciA9IHVuZGVmaW5lZCwgXG4gICAgICAgIHN0YXJ0VGltZTpCTiA9IHVuZGVmaW5lZCwgXG4gICAgICAgIGVuZFRpbWU6Qk4gPSB1bmRlZmluZWQsXG4gICAgICAgIHN0YWtlQW1vdW50OkJOID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGFrZU91dHM6QXJyYXk8VHJhbnNmZXJhYmxlT3V0cHV0PiA9IHVuZGVmaW5lZCxcbiAgICAgICAgcmV3YXJkT3duZXJzOlBhcnNlYWJsZU91dHB1dCA9IHVuZGVmaW5lZCxcbiAgICAgICAgZGVsZWdhdGlvbkZlZTpudW1iZXIgPSB1bmRlZmluZWRcbiAgICApIHtcbiAgICAgICAgc3VwZXIoXG4gICAgICAgICAgICBuZXR3b3JraWQsIFxuICAgICAgICAgICAgYmxvY2tjaGFpbmlkLCBcbiAgICAgICAgICAgIG91dHMsIFxuICAgICAgICAgICAgaW5zLCBcbiAgICAgICAgICAgIG1lbW8sIFxuICAgICAgICAgICAgbm9kZUlELCBcbiAgICAgICAgICAgIHN0YXJ0VGltZSwgXG4gICAgICAgICAgICBlbmRUaW1lLFxuICAgICAgICAgICAgc3Rha2VBbW91bnQsXG4gICAgICAgICAgICBzdGFrZU91dHMsXG4gICAgICAgICAgICByZXdhcmRPd25lcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYodHlwZW9mIGRlbGVnYXRpb25GZWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmKGRlbGVnYXRpb25GZWUgPj0gMCAmJiBkZWxlZ2F0aW9uRmVlIDw9IDEwMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGlvbkZlZSA9IHBhcnNlRmxvYXQoZGVsZWdhdGlvbkZlZS50b0ZpeGVkKDQpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlbGVnYXRpb25GZWVFcnJvcihcIkFkZFZhbGlkYXRvclR4LmNvbnN0cnVjdG9yIC0tIGRlbGVnYXRpb25GZWUgbXVzdCBiZSBpbiB0aGUgcmFuZ2Ugb2YgMCBhbmQgMTAwLCBpbmNsdXNpdmVseS5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59Il19