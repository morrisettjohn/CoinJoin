"use strict";
/**
 * @packageDocumentation
 * @module API-AVM-Credentials
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.NFTCredential = exports.SECPCredential = exports.SelectCredentialClass = void 0;
const constants_1 = require("./constants");
const credentials_1 = require("../../common/credentials");
const errors_1 = require("../../utils/errors");
/**
 * Takes a buffer representing the credential and returns the proper [[Credential]] instance.
 *
 * @param credid A number representing the credential ID parsed prior to the bytes passed in
 *
 * @returns An instance of an [[Credential]]-extended class.
 */
exports.SelectCredentialClass = (credid, ...args) => {
    if (credid === constants_1.AVMConstants.SECPCREDENTIAL || credid === constants_1.AVMConstants.SECPCREDENTIAL_CODECONE) {
        return new SECPCredential(...args);
    }
    if (credid === constants_1.AVMConstants.NFTCREDENTIAL || credid === constants_1.AVMConstants.NFTCREDENTIAL_CODECONE) {
        return new NFTCredential(...args);
    }
    /* istanbul ignore next */
    throw new errors_1.CredIdError("Error - SelectCredentialClass: unknown credid");
};
class SECPCredential extends credentials_1.Credential {
    constructor() {
        super(...arguments);
        this._typeName = "SECPCredential";
        this._codecID = constants_1.AVMConstants.LATESTCODEC;
        this._typeID = this._codecID === 0 ? constants_1.AVMConstants.SECPCREDENTIAL : constants_1.AVMConstants.SECPCREDENTIAL_CODECONE;
    }
    //serialize and deserialize both are inherited
    setCodecID(codecID) {
        if (codecID !== 0 && codecID !== 1) {
            /* istanbul ignore next */
            throw new errors_1.CodecIdError("Error - SECPCredential.setCodecID: invalid codecID. Valid codecIDs are 0 and 1.");
        }
        this._codecID = codecID;
        this._typeID = this._codecID === 0 ? constants_1.AVMConstants.SECPCREDENTIAL : constants_1.AVMConstants.SECPCREDENTIAL_CODECONE;
    }
    getCredentialID() {
        return this._typeID;
    }
    clone() {
        let newbase = new SECPCredential();
        newbase.fromBuffer(this.toBuffer());
        return newbase;
    }
    create(...args) {
        return new SECPCredential(...args);
    }
    select(id, ...args) {
        let newbasetx = exports.SelectCredentialClass(id, ...args);
        return newbasetx;
    }
}
exports.SECPCredential = SECPCredential;
class NFTCredential extends credentials_1.Credential {
    constructor() {
        super(...arguments);
        this._typeName = "NFTCredential";
        this._codecID = constants_1.AVMConstants.LATESTCODEC;
        this._typeID = this._codecID === 0 ? constants_1.AVMConstants.NFTCREDENTIAL : constants_1.AVMConstants.NFTCREDENTIAL_CODECONE;
    }
    //serialize and deserialize both are inherited
    setCodecID(codecID) {
        if (codecID !== 0 && codecID !== 1) {
            /* istanbul ignore next */
            throw new errors_1.CodecIdError("Error - NFTCredential.setCodecID: invalid codecID. Valid codecIDs are 0 and 1.");
        }
        this._codecID = codecID;
        this._typeID = this._codecID === 0 ? constants_1.AVMConstants.NFTCREDENTIAL : constants_1.AVMConstants.NFTCREDENTIAL_CODECONE;
    }
    getCredentialID() {
        return this._typeID;
    }
    clone() {
        let newbase = new NFTCredential();
        newbase.fromBuffer(this.toBuffer());
        return newbase;
    }
    create(...args) {
        return new NFTCredential(...args);
    }
    select(id, ...args) {
        let newbasetx = exports.SelectCredentialClass(id, ...args);
        return newbasetx;
    }
}
exports.NFTCredential = NFTCredential;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JlZGVudGlhbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvYXBpcy9hdm0vY3JlZGVudGlhbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7R0FHRzs7O0FBRUgsMkNBQTJDO0FBQzNDLDBEQUFzRDtBQUN0RCwrQ0FBK0Q7QUFFL0Q7Ozs7OztHQU1HO0FBQ1UsUUFBQSxxQkFBcUIsR0FBRyxDQUFDLE1BQWEsRUFBRSxHQUFHLElBQWUsRUFBYSxFQUFFO0lBQ3BGLElBQUksTUFBTSxLQUFLLHdCQUFZLENBQUMsY0FBYyxJQUFJLE1BQU0sS0FBSyx3QkFBWSxDQUFDLHVCQUF1QixFQUFFO1FBQzdGLE9BQU8sSUFBSSxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNwQztJQUFDLElBQUksTUFBTSxLQUFLLHdCQUFZLENBQUMsYUFBYSxJQUFJLE1BQU0sS0FBSyx3QkFBWSxDQUFDLHNCQUFzQixFQUFFO1FBQzdGLE9BQU8sSUFBSSxhQUFhLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQztLQUNuQztJQUNELDBCQUEwQjtJQUMxQixNQUFNLElBQUksb0JBQVcsQ0FBQywrQ0FBK0MsQ0FBQyxDQUFDO0FBQ3pFLENBQUMsQ0FBQztBQUVGLE1BQWEsY0FBZSxTQUFRLHdCQUFVO0lBQTlDOztRQUNZLGNBQVMsR0FBRyxnQkFBZ0IsQ0FBQztRQUM3QixhQUFRLEdBQUcsd0JBQVksQ0FBQyxXQUFXLENBQUM7UUFDcEMsWUFBTyxHQUFHLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsd0JBQVksQ0FBQyx1QkFBdUIsQ0FBQztJQWdDL0csQ0FBQztJQTlCQyw4Q0FBOEM7SUFFOUMsVUFBVSxDQUFDLE9BQWU7UUFDeEIsSUFBRyxPQUFPLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxDQUFDLEVBQUU7WUFDakMsMEJBQTBCO1lBQ3hCLE1BQU0sSUFBSSxxQkFBWSxDQUFDLGlGQUFpRixDQUFDLENBQUM7U0FDN0c7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztRQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLENBQUMsd0JBQVksQ0FBQyx1QkFBdUIsQ0FBQztJQUMxRyxDQUFDO0lBRUQsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSztRQUNILElBQUksT0FBTyxHQUFrQixJQUFJLGNBQWMsRUFBRSxDQUFDO1FBQ2xELE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDcEMsT0FBTyxPQUFlLENBQUM7SUFDekIsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUFHLElBQVU7UUFDbEIsT0FBTyxJQUFJLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBUyxDQUFDO0lBQzdDLENBQUM7SUFFRCxNQUFNLENBQUMsRUFBUyxFQUFFLEdBQUcsSUFBVTtRQUM3QixJQUFJLFNBQVMsR0FBYyw2QkFBcUIsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUM5RCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBRUY7QUFuQ0Qsd0NBbUNDO0FBRUQsTUFBYSxhQUFjLFNBQVEsd0JBQVU7SUFBN0M7O1FBQ1ksY0FBUyxHQUFHLGVBQWUsQ0FBQztRQUM1QixhQUFRLEdBQUcsd0JBQVksQ0FBQyxXQUFXLENBQUM7UUFDcEMsWUFBTyxHQUFHLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsd0JBQVksQ0FBQyxzQkFBc0IsQ0FBQztJQWdDN0csQ0FBQztJQTlCQyw4Q0FBOEM7SUFFOUMsVUFBVSxDQUFDLE9BQWU7UUFDeEIsSUFBRyxPQUFPLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxDQUFDLEVBQUU7WUFDakMsMEJBQTBCO1lBQ3hCLE1BQU0sSUFBSSxxQkFBWSxDQUFDLGdGQUFnRixDQUFDLENBQUM7U0FDNUc7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU8sQ0FBQztRQUN4QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyx3QkFBWSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsd0JBQVksQ0FBQyxzQkFBc0IsQ0FBQztJQUN4RyxDQUFDO0lBRUQsZUFBZTtRQUNiLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN0QixDQUFDO0lBRUQsS0FBSztRQUNILElBQUksT0FBTyxHQUFpQixJQUFJLGFBQWEsRUFBRSxDQUFDO1FBQ2hELE9BQU8sQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7UUFDcEMsT0FBTyxPQUFlLENBQUM7SUFDekIsQ0FBQztJQUVELE1BQU0sQ0FBQyxHQUFHLElBQVU7UUFDbEIsT0FBTyxJQUFJLGFBQWEsQ0FBQyxHQUFHLElBQUksQ0FBUyxDQUFDO0lBQzVDLENBQUM7SUFFRCxNQUFNLENBQUMsRUFBUyxFQUFFLEdBQUcsSUFBVTtRQUM3QixJQUFJLFNBQVMsR0FBYyw2QkFBcUIsQ0FBQyxFQUFFLEVBQUUsR0FBRyxJQUFJLENBQUMsQ0FBQztRQUM5RCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0NBRUY7QUFuQ0Qsc0NBbUNDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQVBJLUFWTS1DcmVkZW50aWFsc1xuICovXG5cbmltcG9ydCB7IEFWTUNvbnN0YW50cyB9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7IENyZWRlbnRpYWwgfSBmcm9tICcuLi8uLi9jb21tb24vY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgQ3JlZElkRXJyb3IsIENvZGVjSWRFcnJvciB9IGZyb20gJy4uLy4uL3V0aWxzL2Vycm9ycyc7XG5cbi8qKlxuICogVGFrZXMgYSBidWZmZXIgcmVwcmVzZW50aW5nIHRoZSBjcmVkZW50aWFsIGFuZCByZXR1cm5zIHRoZSBwcm9wZXIgW1tDcmVkZW50aWFsXV0gaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGNyZWRpZCBBIG51bWJlciByZXByZXNlbnRpbmcgdGhlIGNyZWRlbnRpYWwgSUQgcGFyc2VkIHByaW9yIHRvIHRoZSBieXRlcyBwYXNzZWQgaW5cbiAqXG4gKiBAcmV0dXJucyBBbiBpbnN0YW5jZSBvZiBhbiBbW0NyZWRlbnRpYWxdXS1leHRlbmRlZCBjbGFzcy5cbiAqL1xuZXhwb3J0IGNvbnN0IFNlbGVjdENyZWRlbnRpYWxDbGFzcyA9IChjcmVkaWQ6bnVtYmVyLCAuLi5hcmdzOkFycmF5PGFueT4pOkNyZWRlbnRpYWwgPT4ge1xuICBpZiAoY3JlZGlkID09PSBBVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUwgfHwgY3JlZGlkID09PSBBVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUxfQ09ERUNPTkUpIHtcbiAgICByZXR1cm4gbmV3IFNFQ1BDcmVkZW50aWFsKC4uLmFyZ3MpO1xuICB9IGlmIChjcmVkaWQgPT09IEFWTUNvbnN0YW50cy5ORlRDUkVERU5USUFMIHx8IGNyZWRpZCA9PT0gQVZNQ29uc3RhbnRzLk5GVENSRURFTlRJQUxfQ09ERUNPTkUpIHtcbiAgICByZXR1cm4gbmV3IE5GVENyZWRlbnRpYWwoLi4uYXJncyk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgdGhyb3cgbmV3IENyZWRJZEVycm9yKFwiRXJyb3IgLSBTZWxlY3RDcmVkZW50aWFsQ2xhc3M6IHVua25vd24gY3JlZGlkXCIpO1xufTtcblxuZXhwb3J0IGNsYXNzIFNFQ1BDcmVkZW50aWFsIGV4dGVuZHMgQ3JlZGVudGlhbCB7XG4gIHByb3RlY3RlZCBfdHlwZU5hbWUgPSBcIlNFQ1BDcmVkZW50aWFsXCI7XG4gIHByb3RlY3RlZCBfY29kZWNJRCA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQztcbiAgcHJvdGVjdGVkIF90eXBlSUQgPSB0aGlzLl9jb2RlY0lEID09PSAwID8gQVZNQ29uc3RhbnRzLlNFQ1BDUkVERU5USUFMIDogQVZNQ29uc3RhbnRzLlNFQ1BDUkVERU5USUFMX0NPREVDT05FO1xuXG4gIC8vc2VyaWFsaXplIGFuZCBkZXNlcmlhbGl6ZSBib3RoIGFyZSBpbmhlcml0ZWRcblxuICBzZXRDb2RlY0lEKGNvZGVjSUQ6IG51bWJlcik6IHZvaWQge1xuICAgIGlmKGNvZGVjSUQgIT09IDAgJiYgY29kZWNJRCAhPT0gMSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgdGhyb3cgbmV3IENvZGVjSWRFcnJvcihcIkVycm9yIC0gU0VDUENyZWRlbnRpYWwuc2V0Q29kZWNJRDogaW52YWxpZCBjb2RlY0lELiBWYWxpZCBjb2RlY0lEcyBhcmUgMCBhbmQgMS5cIik7XG4gICAgfVxuICAgIHRoaXMuX2NvZGVjSUQgPSBjb2RlY0lEO1xuICAgIHRoaXMuX3R5cGVJRCA9IHRoaXMuX2NvZGVjSUQgPT09IDAgPyBBVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUwgOiBBVk1Db25zdGFudHMuU0VDUENSRURFTlRJQUxfQ09ERUNPTkU7XG4gIH1cblxuICBnZXRDcmVkZW50aWFsSUQoKTpudW1iZXIge1xuICAgIHJldHVybiB0aGlzLl90eXBlSUQ7XG4gIH1cblxuICBjbG9uZSgpOnRoaXMge1xuICAgIGxldCBuZXdiYXNlOlNFQ1BDcmVkZW50aWFsID0gbmV3IFNFQ1BDcmVkZW50aWFsKCk7XG4gICAgbmV3YmFzZS5mcm9tQnVmZmVyKHRoaXMudG9CdWZmZXIoKSk7XG4gICAgcmV0dXJuIG5ld2Jhc2UgYXMgdGhpcztcbiAgfVxuXG4gIGNyZWF0ZSguLi5hcmdzOmFueVtdKTp0aGlzIHtcbiAgICByZXR1cm4gbmV3IFNFQ1BDcmVkZW50aWFsKC4uLmFyZ3MpIGFzIHRoaXM7XG4gIH1cblxuICBzZWxlY3QoaWQ6bnVtYmVyLCAuLi5hcmdzOmFueVtdKTpDcmVkZW50aWFsIHtcbiAgICBsZXQgbmV3YmFzZXR4OkNyZWRlbnRpYWwgPSBTZWxlY3RDcmVkZW50aWFsQ2xhc3MoaWQsIC4uLmFyZ3MpO1xuICAgIHJldHVybiBuZXdiYXNldHg7XG4gIH1cblxufVxuXG5leHBvcnQgY2xhc3MgTkZUQ3JlZGVudGlhbCBleHRlbmRzIENyZWRlbnRpYWwge1xuICBwcm90ZWN0ZWQgX3R5cGVOYW1lID0gXCJORlRDcmVkZW50aWFsXCI7XG4gIHByb3RlY3RlZCBfY29kZWNJRCA9IEFWTUNvbnN0YW50cy5MQVRFU1RDT0RFQztcbiAgcHJvdGVjdGVkIF90eXBlSUQgPSB0aGlzLl9jb2RlY0lEID09PSAwID8gQVZNQ29uc3RhbnRzLk5GVENSRURFTlRJQUwgOiBBVk1Db25zdGFudHMuTkZUQ1JFREVOVElBTF9DT0RFQ09ORTtcblxuICAvL3NlcmlhbGl6ZSBhbmQgZGVzZXJpYWxpemUgYm90aCBhcmUgaW5oZXJpdGVkXG5cbiAgc2V0Q29kZWNJRChjb2RlY0lEOiBudW1iZXIpOiB2b2lkIHtcbiAgICBpZihjb2RlY0lEICE9PSAwICYmIGNvZGVjSUQgIT09IDEpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHRocm93IG5ldyBDb2RlY0lkRXJyb3IoXCJFcnJvciAtIE5GVENyZWRlbnRpYWwuc2V0Q29kZWNJRDogaW52YWxpZCBjb2RlY0lELiBWYWxpZCBjb2RlY0lEcyBhcmUgMCBhbmQgMS5cIik7XG4gICAgfVxuICAgIHRoaXMuX2NvZGVjSUQgPSBjb2RlY0lEO1xuICAgIHRoaXMuX3R5cGVJRCA9IHRoaXMuX2NvZGVjSUQgPT09IDAgPyBBVk1Db25zdGFudHMuTkZUQ1JFREVOVElBTCA6IEFWTUNvbnN0YW50cy5ORlRDUkVERU5USUFMX0NPREVDT05FO1xuICB9XG5cbiAgZ2V0Q3JlZGVudGlhbElEKCk6bnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5fdHlwZUlEO1xuICB9XG5cbiAgY2xvbmUoKTp0aGlzIHtcbiAgICBsZXQgbmV3YmFzZTpORlRDcmVkZW50aWFsID0gbmV3IE5GVENyZWRlbnRpYWwoKTtcbiAgICBuZXdiYXNlLmZyb21CdWZmZXIodGhpcy50b0J1ZmZlcigpKTtcbiAgICByZXR1cm4gbmV3YmFzZSBhcyB0aGlzO1xuICB9XG5cbiAgY3JlYXRlKC4uLmFyZ3M6YW55W10pOnRoaXMge1xuICAgIHJldHVybiBuZXcgTkZUQ3JlZGVudGlhbCguLi5hcmdzKSBhcyB0aGlzO1xuICB9XG5cbiAgc2VsZWN0KGlkOm51bWJlciwgLi4uYXJnczphbnlbXSk6Q3JlZGVudGlhbCB7XG4gICAgbGV0IG5ld2Jhc2V0eDpDcmVkZW50aWFsID0gU2VsZWN0Q3JlZGVudGlhbENsYXNzKGlkLCAuLi5hcmdzKTtcbiAgICByZXR1cm4gbmV3YmFzZXR4O1xuICB9XG5cbn1cbiJdfQ==