"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StandardUTXOSet = exports.StandardUTXO = void 0;
/**
 * @packageDocumentation
 * @module Common-UTXOs
 */
const buffer_1 = require("buffer/");
const bintools_1 = __importDefault(require("../utils/bintools"));
const bn_js_1 = __importDefault(require("bn.js"));
const output_1 = require("./output");
const helperfunctions_1 = require("../utils/helperfunctions");
const serialization_1 = require("../utils/serialization");
const errors_1 = require("../utils/errors");
/**
 * @ignore
 */
const bintools = bintools_1.default.getInstance();
const serializer = serialization_1.Serialization.getInstance();
/**
 * Class for representing a single StandardUTXO.
 */
class StandardUTXO extends serialization_1.Serializable {
    /**
       * Class for representing a single StandardUTXO.
       *
       * @param codecID Optional number which specifies the codeID of the UTXO. Default 1
       * @param txid Optional {@link https://github.com/feross/buffer|Buffer} of transaction ID for the StandardUTXO
       * @param txidx Optional {@link https://github.com/feross/buffer|Buffer} or number for the index of the transaction's [[Output]]
       * @param assetid Optional {@link https://github.com/feross/buffer|Buffer} of the asset ID for the StandardUTXO
       * @param outputid Optional {@link https://github.com/feross/buffer|Buffer} or number of the output ID for the StandardUTXO
       */
    constructor(codecID = 0, txid = undefined, outputidx = undefined, assetid = undefined, output = undefined) {
        super();
        this._typeName = "StandardUTXO";
        this._typeID = undefined;
        this.codecid = buffer_1.Buffer.alloc(2);
        this.txid = buffer_1.Buffer.alloc(32);
        this.outputidx = buffer_1.Buffer.alloc(4);
        this.assetid = buffer_1.Buffer.alloc(32);
        this.output = undefined;
        /**
           * Returns the numeric representation of the CodecID.
           */
        this.getCodecID = () => this.codecid.readUInt8(0);
        /**
         * Returns the {@link https://github.com/feross/buffer|Buffer} representation of the CodecID
          */
        this.getCodecIDBuffer = () => this.codecid;
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer} of the TxID.
           */
        this.getTxID = () => this.txid;
        /**
           * Returns a {@link https://github.com/feross/buffer|Buffer}  of the OutputIdx.
           */
        this.getOutputIdx = () => this.outputidx;
        /**
           * Returns the assetID as a {@link https://github.com/feross/buffer|Buffer}.
           */
        this.getAssetID = () => this.assetid;
        /**
           * Returns the UTXOID as a base-58 string (UTXOID is a string )
           */
        this.getUTXOID = () => bintools.bufferToB58(buffer_1.Buffer.concat([this.getTxID(), this.getOutputIdx()]));
        /**
         * Returns a reference to the output;
        */
        this.getOutput = () => this.output;
        if (typeof codecID !== 'undefined') {
            this.codecid.writeUInt8(codecID, 0);
        }
        if (typeof txid !== 'undefined') {
            this.txid = txid;
        }
        if (typeof outputidx === 'number') {
            this.outputidx.writeUInt32BE(outputidx, 0);
        }
        else if (outputidx instanceof buffer_1.Buffer) {
            this.outputidx = outputidx;
        }
        if (typeof assetid !== 'undefined') {
            this.assetid = assetid;
        }
        if (typeof output !== 'undefined') {
            this.output = output;
        }
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        return Object.assign(Object.assign({}, fields), { "codecid": serializer.encoder(this.codecid, encoding, "Buffer", "decimalString"), "txid": serializer.encoder(this.txid, encoding, "Buffer", "cb58"), "outputidx": serializer.encoder(this.outputidx, encoding, "Buffer", "decimalString"), "assetid": serializer.encoder(this.assetid, encoding, "Buffer", "cb58"), "output": this.output.serialize(encoding) });
    }
    ;
    deserialize(fields, encoding = "hex") {
        super.deserialize(fields, encoding);
        this.codecid = serializer.decoder(fields["codecid"], encoding, "decimalString", "Buffer", 2);
        this.txid = serializer.decoder(fields["txid"], encoding, "cb58", "Buffer", 32);
        this.outputidx = serializer.decoder(fields["outputidx"], encoding, "decimalString", "Buffer", 4);
        this.assetid = serializer.decoder(fields["assetid"], encoding, "cb58", "Buffer", 32);
    }
    /**
       * Returns a {@link https://github.com/feross/buffer|Buffer} representation of the [[StandardUTXO]].
       */
    toBuffer() {
        const outbuff = this.output.toBuffer();
        const outputidbuffer = buffer_1.Buffer.alloc(4);
        outputidbuffer.writeUInt32BE(this.output.getOutputID(), 0);
        const barr = [this.codecid, this.txid, this.outputidx, this.assetid, outputidbuffer, outbuff];
        return buffer_1.Buffer.concat(barr, this.codecid.length + this.txid.length
            + this.outputidx.length + this.assetid.length
            + outputidbuffer.length + outbuff.length);
    }
}
exports.StandardUTXO = StandardUTXO;
/**
 * Class representing a set of [[StandardUTXO]]s.
 */
class StandardUTXOSet extends serialization_1.Serializable {
    constructor() {
        super(...arguments);
        this._typeName = "StandardUTXOSet";
        this._typeID = undefined;
        this.utxos = {};
        this.addressUTXOs = {}; // maps address to utxoids:locktime
        /**
         * Returns true if the [[StandardUTXO]] is in the StandardUTXOSet.
         *
         * @param utxo Either a [[StandardUTXO]] a cb58 serialized string representing a StandardUTXO
         */
        this.includes = (utxo) => {
            let utxoX = undefined;
            let utxoid = undefined;
            try {
                utxoX = this.parseUTXO(utxo);
                utxoid = utxoX.getUTXOID();
            }
            catch (e) {
                if (e instanceof Error) {
                    console.log(e.message);
                }
                else {
                    console.log(e);
                }
                return false;
            }
            return (utxoid in this.utxos);
        };
        /**
           * Removes a [[StandardUTXO]] from the [[StandardUTXOSet]] if it exists.
           *
           * @param utxo Either a [[StandardUTXO]] an cb58 serialized string representing a StandardUTXO
           *
           * @returns A [[StandardUTXO]] if it was removed and undefined if nothing was removed.
           */
        this.remove = (utxo) => {
            let utxovar = undefined;
            try {
                utxovar = this.parseUTXO(utxo);
            }
            catch (e) {
                if (e instanceof Error) {
                    console.log(e.message);
                }
                else {
                    console.log(e);
                }
                return undefined;
            }
            const utxoid = utxovar.getUTXOID();
            if (!(utxoid in this.utxos)) {
                return undefined;
            }
            delete this.utxos[utxoid];
            const addresses = Object.keys(this.addressUTXOs);
            for (let i = 0; i < addresses.length; i++) {
                if (utxoid in this.addressUTXOs[addresses[i]]) {
                    delete this.addressUTXOs[addresses[i]][utxoid];
                }
            }
            return utxovar;
        };
        /**
           * Removes an array of [[StandardUTXO]]s to the [[StandardUTXOSet]].
           *
           * @param utxo Either a [[StandardUTXO]] an cb58 serialized string representing a StandardUTXO
           * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
           *
           * @returns An array of UTXOs which were removed.
           */
        this.removeArray = (utxos) => {
            const removed = [];
            for (let i = 0; i < utxos.length; i++) {
                const result = this.remove(utxos[i]);
                if (typeof result !== 'undefined') {
                    removed.push(result);
                }
            }
            return removed;
        };
        /**
           * Gets a [[StandardUTXO]] from the [[StandardUTXOSet]] by its UTXOID.
           *
           * @param utxoid String representing the UTXOID
           *
           * @returns A [[StandardUTXO]] if it exists in the set.
           */
        this.getUTXO = (utxoid) => this.utxos[utxoid];
        /**
           * Gets all the [[StandardUTXO]]s, optionally that match with UTXOIDs in an array
           *
           * @param utxoids An optional array of UTXOIDs, returns all [[StandardUTXO]]s if not provided
           *
           * @returns An array of [[StandardUTXO]]s.
           */
        this.getAllUTXOs = (utxoids = undefined) => {
            let results = [];
            if (typeof utxoids !== 'undefined' && Array.isArray(utxoids)) {
                for (let i = 0; i < utxoids.length; i++) {
                    if (utxoids[i] in this.utxos && !(utxoids[i] in results)) {
                        results.push(this.utxos[utxoids[i]]);
                    }
                }
            }
            else {
                results = Object.values(this.utxos);
            }
            return results;
        };
        /**
           * Gets all the [[StandardUTXO]]s as strings, optionally that match with UTXOIDs in an array.
           *
           * @param utxoids An optional array of UTXOIDs, returns all [[StandardUTXO]]s if not provided
           *
           * @returns An array of [[StandardUTXO]]s as cb58 serialized strings.
           */
        this.getAllUTXOStrings = (utxoids = undefined) => {
            const results = [];
            const utxos = Object.keys(this.utxos);
            if (typeof utxoids !== 'undefined' && Array.isArray(utxoids)) {
                for (let i = 0; i < utxoids.length; i++) {
                    if (utxoids[i] in this.utxos) {
                        results.push(this.utxos[utxoids[i]].toString());
                    }
                }
            }
            else {
                for (const u of utxos) {
                    results.push(this.utxos[u].toString());
                }
            }
            return results;
        };
        /**
           * Given an address or array of addresses, returns all the UTXOIDs for those addresses
           *
           * @param address An array of address {@link https://github.com/feross/buffer|Buffer}s
           * @param spendable If true, only retrieves UTXOIDs whose locktime has passed
           *
           * @returns An array of addresses.
           */
        this.getUTXOIDs = (addresses = undefined, spendable = true) => {
            if (typeof addresses !== 'undefined') {
                const results = [];
                const now = helperfunctions_1.UnixNow();
                for (let i = 0; i < addresses.length; i++) {
                    if (addresses[i].toString('hex') in this.addressUTXOs) {
                        const entries = Object.entries(this.addressUTXOs[addresses[i].toString('hex')]);
                        for (const [utxoid, locktime] of entries) {
                            if ((results.indexOf(utxoid) === -1
                                && (spendable && locktime.lte(now)))
                                || !spendable) {
                                results.push(utxoid);
                            }
                        }
                    }
                }
                return results;
            }
            return Object.keys(this.utxos);
        };
        /**
           * Gets the addresses in the [[StandardUTXOSet]] and returns an array of {@link https://github.com/feross/buffer|Buffer}.
           */
        this.getAddresses = () => Object.keys(this.addressUTXOs)
            .map((k) => buffer_1.Buffer.from(k, 'hex'));
        /**
           * Returns the balance of a set of addresses in the StandardUTXOSet.
           *
           * @param addresses An array of addresses
           * @param assetID Either a {@link https://github.com/feross/buffer|Buffer} or an cb58 serialized representation of an AssetID
           * @param asOf The timestamp to verify the transaction against as a {@link https://github.com/indutny/bn.js/|BN}
           *
           * @returns Returns the total balance as a {@link https://github.com/indutny/bn.js/|BN}.
           */
        this.getBalance = (addresses, assetID, asOf = undefined) => {
            const utxoids = this.getUTXOIDs(addresses);
            const utxos = this.getAllUTXOs(utxoids);
            let spend = new bn_js_1.default(0);
            let asset;
            if (typeof assetID === 'string') {
                asset = bintools.cb58Decode(assetID);
            }
            else {
                asset = assetID;
            }
            for (let i = 0; i < utxos.length; i++) {
                if (utxos[i].getOutput() instanceof output_1.StandardAmountOutput
                    && utxos[i].getAssetID().toString('hex') === asset.toString('hex')
                    && utxos[i].getOutput().meetsThreshold(addresses, asOf)) {
                    spend = spend.add(utxos[i].getOutput().getAmount());
                }
            }
            return spend;
        };
        /**
           * Gets all the Asset IDs, optionally that match with Asset IDs in an array
           *
           * @param utxoids An optional array of Addresses as string or Buffer, returns all Asset IDs if not provided
           *
           * @returns An array of {@link https://github.com/feross/buffer|Buffer} representing the Asset IDs.
           */
        this.getAssetIDs = (addresses = undefined) => {
            const results = new Set();
            let utxoids = [];
            if (typeof addresses !== 'undefined') {
                utxoids = this.getUTXOIDs(addresses);
            }
            else {
                utxoids = this.getUTXOIDs();
            }
            for (let i = 0; i < utxoids.length; i++) {
                if (utxoids[i] in this.utxos && !(utxoids[i] in results)) {
                    results.add(this.utxos[utxoids[i]].getAssetID());
                }
            }
            return [...results];
        };
        /**
           * Returns a new set with copy of UTXOs in this and set parameter.
           *
           * @param utxoset The [[StandardUTXOSet]] to merge with this one
           * @param hasUTXOIDs Will subselect a set of [[StandardUTXO]]s which have the UTXOIDs provided in this array, defults to all UTXOs
           *
           * @returns A new StandardUTXOSet that contains all the filtered elements.
           */
        this.merge = (utxoset, hasUTXOIDs = undefined) => {
            const results = this.create();
            const utxos1 = this.getAllUTXOs(hasUTXOIDs);
            const utxos2 = utxoset.getAllUTXOs(hasUTXOIDs);
            const process = (utxo) => {
                results.add(utxo);
            };
            utxos1.forEach(process);
            utxos2.forEach(process);
            return results;
        };
        /**
           * Set intersetion between this set and a parameter.
           *
           * @param utxoset The set to intersect
           *
           * @returns A new StandardUTXOSet containing the intersection
           */
        this.intersection = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => us2.includes(utxoid));
            return this.merge(utxoset, results);
        };
        /**
           * Set difference between this set and a parameter.
           *
           * @param utxoset The set to difference
           *
           * @returns A new StandardUTXOSet containing the difference
           */
        this.difference = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => !us2.includes(utxoid));
            return this.merge(utxoset, results);
        };
        /**
           * Set symmetrical difference between this set and a parameter.
           *
           * @param utxoset The set to symmetrical difference
           *
           * @returns A new StandardUTXOSet containing the symmetrical difference
           */
        this.symDifference = (utxoset) => {
            const us1 = this.getUTXOIDs();
            const us2 = utxoset.getUTXOIDs();
            const results = us1.filter((utxoid) => !us2.includes(utxoid))
                .concat(us2.filter((utxoid) => !us1.includes(utxoid)));
            return this.merge(utxoset, results);
        };
        /**
           * Set union between this set and a parameter.
           *
           * @param utxoset The set to union
           *
           * @returns A new StandardUTXOSet containing the union
           */
        this.union = (utxoset) => this.merge(utxoset);
        /**
           * Merges a set by the rule provided.
           *
           * @param utxoset The set to merge by the MergeRule
           * @param mergeRule The [[MergeRule]] to apply
           *
           * @returns A new StandardUTXOSet containing the merged data
           *
           * @remarks
           * The merge rules are as follows:
           *   * "intersection" - the intersection of the set
           *   * "differenceSelf" - the difference between the existing data and new set
           *   * "differenceNew" - the difference between the new data and the existing set
           *   * "symDifference" - the union of the differences between both sets of data
           *   * "union" - the unique set of all elements contained in both sets
           *   * "unionMinusNew" - the unique set of all elements contained in both sets, excluding values only found in the new set
           *   * "unionMinusSelf" - the unique set of all elements contained in both sets, excluding values only found in the existing set
           */
        this.mergeByRule = (utxoset, mergeRule) => {
            let uSet;
            switch (mergeRule) {
                case 'intersection':
                    return this.intersection(utxoset);
                case 'differenceSelf':
                    return this.difference(utxoset);
                case 'differenceNew':
                    return utxoset.difference(this);
                case 'symDifference':
                    return this.symDifference(utxoset);
                case 'union':
                    return this.union(utxoset);
                case 'unionMinusNew':
                    uSet = this.union(utxoset);
                    return uSet.difference(utxoset);
                case 'unionMinusSelf':
                    uSet = this.union(utxoset);
                    return uSet.difference(this);
                default:
                    throw new errors_1.MergeRuleError("Error - StandardUTXOSet.mergeByRule: bad MergeRule");
            }
        };
    }
    serialize(encoding = "hex") {
        let fields = super.serialize(encoding);
        let utxos = {};
        for (let utxoid in this.utxos) {
            let utxoidCleaned = serializer.encoder(utxoid, encoding, "base58", "base58");
            utxos[utxoidCleaned] = this.utxos[utxoid].serialize(encoding);
        }
        let addressUTXOs = {};
        for (let address in this.addressUTXOs) {
            let addressCleaned = serializer.encoder(address, encoding, "hex", "cb58");
            let utxobalance = {};
            for (let utxoid in this.addressUTXOs[address]) {
                let utxoidCleaned = serializer.encoder(utxoid, encoding, "base58", "base58");
                utxobalance[utxoidCleaned] = serializer.encoder(this.addressUTXOs[address][utxoid], encoding, "BN", "decimalString");
            }
            addressUTXOs[addressCleaned] = utxobalance;
        }
        return Object.assign(Object.assign({}, fields), { utxos,
            addressUTXOs });
    }
    ;
    /**
       * Adds a [[StandardUTXO]] to the StandardUTXOSet.
       *
       * @param utxo Either a [[StandardUTXO]] an cb58 serialized string representing a StandardUTXO
       * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
       *
       * @returns A [[StandardUTXO]] if one was added and undefined if nothing was added.
       */
    add(utxo, overwrite = false) {
        let utxovar = undefined;
        try {
            utxovar = this.parseUTXO(utxo);
        }
        catch (e) {
            if (e instanceof Error) {
                console.log(e.message);
            }
            else {
                console.log(e);
            }
            return undefined;
        }
        const utxoid = utxovar.getUTXOID();
        if (!(utxoid in this.utxos) || overwrite === true) {
            this.utxos[utxoid] = utxovar;
            const addresses = utxovar.getOutput().getAddresses();
            const locktime = utxovar.getOutput().getLocktime();
            for (let i = 0; i < addresses.length; i++) {
                const address = addresses[i].toString('hex');
                if (!(address in this.addressUTXOs)) {
                    this.addressUTXOs[address] = {};
                }
                this.addressUTXOs[address][utxoid] = locktime;
            }
            return utxovar;
        }
        return undefined;
    }
    ;
    /**
       * Adds an array of [[StandardUTXO]]s to the [[StandardUTXOSet]].
       *
       * @param utxo Either a [[StandardUTXO]] an cb58 serialized string representing a StandardUTXO
       * @param overwrite If true, if the UTXOID already exists, overwrite it... default false
       *
       * @returns An array of StandardUTXOs which were added.
       */
    addArray(utxos, overwrite = false) {
        const added = [];
        for (let i = 0; i < utxos.length; i++) {
            let result = this.add(utxos[i], overwrite);
            if (typeof result !== 'undefined') {
                added.push(result);
            }
        }
        return added;
    }
    ;
    filter(args, lambda) {
        let newset = this.clone();
        let utxos = this.getAllUTXOs();
        for (let i = 0; i < utxos.length; i++) {
            if (lambda(utxos[i], ...args) === false) {
                newset.remove(utxos[i]);
            }
        }
        return newset;
    }
}
exports.StandardUTXOSet = StandardUTXOSet;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXR4b3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvY29tbW9uL3V0eG9zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7OztBQUFBOzs7R0FHRztBQUNILG9DQUFpQztBQUNqQyxpRUFBeUM7QUFDekMsa0RBQXVCO0FBQ3ZCLHFDQUF3RDtBQUN4RCw4REFBbUQ7QUFFbkQsMERBQXlGO0FBQ3pGLDRDQUFpRDtBQUVqRDs7R0FFRztBQUNILE1BQU0sUUFBUSxHQUFHLGtCQUFRLENBQUMsV0FBVyxFQUFFLENBQUM7QUFDeEMsTUFBTSxVQUFVLEdBQUcsNkJBQWEsQ0FBQyxXQUFXLEVBQUUsQ0FBQztBQUUvQzs7R0FFRztBQUNILE1BQXNCLFlBQWEsU0FBUSw0QkFBWTtJQXdHckQ7Ozs7Ozs7O1NBUUs7SUFDTCxZQUFZLFVBQWlCLENBQUMsRUFBRSxPQUFjLFNBQVMsRUFDckQsWUFBNEIsU0FBUyxFQUNyQyxVQUFpQixTQUFTLEVBQzFCLFNBQWdCLFNBQVM7UUFDekIsS0FBSyxFQUFFLENBQUM7UUFwSEEsY0FBUyxHQUFHLGNBQWMsQ0FBQztRQUMzQixZQUFPLEdBQUcsU0FBUyxDQUFDO1FBcUJwQixZQUFPLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNqQyxTQUFJLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUMvQixjQUFTLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxZQUFPLEdBQVUsZUFBTSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsQ0FBQztRQUNsQyxXQUFNLEdBQVUsU0FBUyxDQUFDO1FBRXBDOzthQUVLO1FBQ0wsZUFBVSxHQUFHLEdBRUwsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBRXJDOztZQUVJO1FBQ0oscUJBQWdCLEdBQUcsR0FBVSxFQUFF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RCxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0lBQUEsQ0FBQztJQUVGOzs7Ozs7O1NBT0s7SUFDTCxRQUFRLENBQUMsS0FBK0IsRUFBRSxZQUFvQixLQUFLO1FBQ2pFLE1BQU0sS0FBSyxHQUFvQixFQUFFLENBQUM7UUFDbEMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7WUFDckMsSUFBSSxNQUFNLEdBQWEsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDckQsSUFBSSxPQUFPLE1BQU0sS0FBSyxXQUFXLEVBQUU7Z0JBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDdEI7U0FDRjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUFBLENBQUM7SUEwTUYsTUFBTSxDQUFDLElBQVUsRUFBRSxNQUFrRDtRQUNuRSxJQUFJLE1BQU0sR0FBUSxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFDL0IsSUFBSSxLQUFLLEdBQW9CLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNoRCxLQUFJLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBQztZQUNuQyxJQUFHLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsR0FBRyxJQUFJLENBQUMsS0FBSyxLQUFLLEVBQUU7Z0JBQ3RDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekI7U0FDRjtRQUNELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FtSEY7QUFwYkQsMENBb2JDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQ29tbW9uLVVUWE9zXG4gKi9cbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlci8nO1xuaW1wb3J0IEJpblRvb2xzIGZyb20gJy4uL3V0aWxzL2JpbnRvb2xzJztcbmltcG9ydCBCTiBmcm9tIFwiYm4uanNcIjtcbmltcG9ydCB7IE91dHB1dCwgU3RhbmRhcmRBbW91bnRPdXRwdXQgfSBmcm9tICcuL291dHB1dCc7XG5pbXBvcnQgeyBVbml4Tm93IH0gZnJvbSAnLi4vdXRpbHMvaGVscGVyZnVuY3Rpb25zJztcbmltcG9ydCB7IE1lcmdlUnVsZSB9IGZyb20gJy4uL3V0aWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBTZXJpYWxpemFibGUsIFNlcmlhbGl6YXRpb24sIFNlcmlhbGl6ZWRFbmNvZGluZyB9IGZyb20gJy4uL3V0aWxzL3NlcmlhbGl6YXRpb24nO1xuaW1wb3J0IHsgTWVyZ2VSdWxlRXJyb3IgfSBmcm9tICcuLi91dGlscy9lcnJvcnMnO1xuXG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuY29uc3Qgc2VyaWFsaXplciA9IFNlcmlhbGl6YXRpb24uZ2V0SW5zdGFuY2UoKTtcblxuLyoqXG4gKiBDbGFzcyBmb3IgcmVwcmVzZW50aW5nIGEgc2luZ2xlIFN0YW5kYXJkVVRYTy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFN0YW5kYXJkVVRYTyBleHRlbmRzIFNlcmlhbGl6YWJsZXtcbiAgcHJvdGVjdGVkIF90eXBlTmFtZSA9IFwiU3RhbmRhcmRVVFhPXCI7XG4gIHByb3RlY3RlZCBfdHlwZUlEID0gdW5kZWZpbmVkO1xuXG4gIHNlcmlhbGl6ZShlbmNvZGluZzpTZXJpYWxpemVkRW5jb2RpbmcgPSBcImhleFwiKTpvYmplY3Qge1xuICAgIGxldCBmaWVsZHM6b2JqZWN0ID0gc3VwZXIuc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmllbGRzLFxuICAgICAgXCJjb2RlY2lkXCI6IHNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLmNvZGVjaWQsIGVuY29kaW5nLCBcIkJ1ZmZlclwiLCBcImRlY2ltYWxTdHJpbmdcIiksXG4gICAgICBcInR4aWRcIjogc2VyaWFsaXplci5lbmNvZGVyKHRoaXMudHhpZCwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiY2I1OFwiKSxcbiAgICAgIFwib3V0cHV0aWR4XCI6IHNlcmlhbGl6ZXIuZW5jb2Rlcih0aGlzLm91dHB1dGlkeCwgZW5jb2RpbmcsIFwiQnVmZmVyXCIsIFwiZGVjaW1hbFN0cmluZ1wiKSxcbiAgICAgIFwiYXNzZXRpZFwiOiBzZXJpYWxpemVyLmVuY29kZXIodGhpcy5hc3NldGlkLCBlbmNvZGluZywgXCJCdWZmZXJcIiwgXCJjYjU4XCIpLFxuICAgICAgXCJvdXRwdXRcIjogdGhpcy5vdXRwdXQuc2VyaWFsaXplKGVuY29kaW5nKVxuICAgIH1cbiAgfTtcbiAgZGVzZXJpYWxpemUoZmllbGRzOm9iamVjdCwgZW5jb2Rpbmc6U2VyaWFsaXplZEVuY29kaW5nID0gXCJoZXhcIikge1xuICAgIHN1cGVyLmRlc2VyaWFsaXplKGZpZWxkcywgZW5jb2RpbmcpO1xuICAgIHRoaXMuY29kZWNpZCA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJjb2RlY2lkXCJdLCBlbmNvZGluZywgXCJkZWNpbWFsU3RyaW5nXCIsIFwiQnVmZmVyXCIsIDIpO1xuICAgIHRoaXMudHhpZCA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJ0eGlkXCJdLCBlbmNvZGluZywgXCJjYjU4XCIsIFwiQnVmZmVyXCIsIDMyKTtcbiAgICB0aGlzLm91dHB1dGlkeCA9IHNlcmlhbGl6ZXIuZGVjb2RlcihmaWVsZHNbXCJvdXRwdXRpZHhcIl0sIGVuY29kaW5nLCBcImRlY2ltYWxTdHJpbmdcIiwgXCJCdWZmZXJcIiwgNCk7XG4gICAgdGhpcy5hc3NldGlkID0gc2VyaWFsaXplci5kZWNvZGVyKGZpZWxkc1tcImFzc2V0aWRcIl0sIGVuY29kaW5nLCBcImNiNThcIiwgXCJCdWZmZXJcIiwgMzIpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGNvZGVjaWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDIpO1xuICBwcm90ZWN0ZWQgdHhpZDpCdWZmZXIgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICBwcm90ZWN0ZWQgb3V0cHV0aWR4OkJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbiAgcHJvdGVjdGVkIGFzc2V0aWQ6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDMyKTtcbiAgcHJvdGVjdGVkIG91dHB1dDpPdXRwdXQgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbnVtZXJpYyByZXByZXNlbnRhdGlvbiBvZiB0aGUgQ29kZWNJRC5cbiAgICAgKi9cbiAgZ2V0Q29kZWNJRCA9ICgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIDpudW1iZXIgPT4gdGhpcy5jb2RlY2lkLnJlYWRVSW50OCgwKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIENvZGVjSURcbiAgICAqL1xuICBnZXRDb2RlY0lEQnVmZmVyID0gKCk6QnVmZmVyID0+IHRoaXMuY29kZWNpZDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb2YgdGhlIFR4SUQuXG4gICAgICovXG4gIGdldFR4SUQgPSAoKVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICA6QnVmZmVyID0+IHRoaXMudHhpZDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gIG9mIHRoZSBPdXRwdXRJZHguXG4gICAgICovXG4gIGdldE91dHB1dElkeCA9ICgpXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIDpCdWZmZXIgPT4gdGhpcy5vdXRwdXRpZHg7XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXNzZXRJRCBhcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqL1xuICBnZXRBc3NldElEID0gKCk6QnVmZmVyID0+IHRoaXMuYXNzZXRpZDtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBVVFhPSUQgYXMgYSBiYXNlLTU4IHN0cmluZyAoVVRYT0lEIGlzIGEgc3RyaW5nIClcbiAgICAgKi9cbiAgZ2V0VVRYT0lEID0gKClcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgOnN0cmluZyA9PiBiaW50b29scy5idWZmZXJUb0I1OChCdWZmZXIuY29uY2F0KFt0aGlzLmdldFR4SUQoKSwgdGhpcy5nZXRPdXRwdXRJZHgoKV0pKTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgb3V0cHV0O1xuICAqL1xuICBnZXRPdXRwdXQgPSAoKTpPdXRwdXQgPT4gdGhpcy5vdXRwdXQ7XG5cbiAgLyoqXG4gICAqIFRha2VzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhbiBbW1N0YW5kYXJkVVRYT11dLCBwYXJzZXMgaXQsIHBvcHVsYXRlcyB0aGUgY2xhc3MsIGFuZCByZXR1cm5zIHRoZSBsZW5ndGggb2YgdGhlIFN0YW5kYXJkVVRYTyBpbiBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIGJ5dGVzIEEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gY29udGFpbmluZyBhIHJhdyBbW1N0YW5kYXJkVVRYT11dXG4gICAqL1xuICBhYnN0cmFjdCBmcm9tQnVmZmVyKGJ5dGVzOkJ1ZmZlciwgb2Zmc2V0PzpudW1iZXIpOm51bWJlcjtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gcmVwcmVzZW50YXRpb24gb2YgdGhlIFtbU3RhbmRhcmRVVFhPXV0uXG4gICAgICovXG4gIHRvQnVmZmVyKCk6QnVmZmVyIHtcbiAgICBjb25zdCBvdXRidWZmOkJ1ZmZlciA9IHRoaXMub3V0cHV0LnRvQnVmZmVyKCk7XG4gICAgY29uc3Qgb3V0cHV0aWRidWZmZXI6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgIG91dHB1dGlkYnVmZmVyLndyaXRlVUludDMyQkUodGhpcy5vdXRwdXQuZ2V0T3V0cHV0SUQoKSwgMCk7XG4gICAgY29uc3QgYmFycjpBcnJheTxCdWZmZXI+ID0gW3RoaXMuY29kZWNpZCwgdGhpcy50eGlkLCB0aGlzLm91dHB1dGlkeCwgdGhpcy5hc3NldGlkLCBvdXRwdXRpZGJ1ZmZlciwgb3V0YnVmZl07XG4gICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoYmFyciwgXG4gICAgICB0aGlzLmNvZGVjaWQubGVuZ3RoICsgdGhpcy50eGlkLmxlbmd0aCBcbiAgICAgICsgdGhpcy5vdXRwdXRpZHgubGVuZ3RoICsgdGhpcy5hc3NldGlkLmxlbmd0aFxuICAgICAgKyBvdXRwdXRpZGJ1ZmZlci5sZW5ndGggKyBvdXRidWZmLmxlbmd0aCk7XG4gIH1cblxuICBhYnN0cmFjdCBmcm9tU3RyaW5nKHNlcmlhbGl6ZWQ6c3RyaW5nKTpudW1iZXI7XG5cbiAgYWJzdHJhY3QgdG9TdHJpbmcoKTpzdHJpbmc7XG5cbiAgYWJzdHJhY3QgY2xvbmUoKTp0aGlzO1xuXG4gIGFic3RyYWN0IGNyZWF0ZShjb2RlY0lEPzpudW1iZXIsIHR4aWQ/OkJ1ZmZlcixcbiAgICBvdXRwdXRpZHg/OkJ1ZmZlciB8IG51bWJlcixcbiAgICBhc3NldGlkPzpCdWZmZXIsXG4gICAgb3V0cHV0PzpPdXRwdXQpOnRoaXM7XG5cbiAgLyoqXG4gICAgICogQ2xhc3MgZm9yIHJlcHJlc2VudGluZyBhIHNpbmdsZSBTdGFuZGFyZFVUWE8uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29kZWNJRCBPcHRpb25hbCBudW1iZXIgd2hpY2ggc3BlY2lmaWVzIHRoZSBjb2RlSUQgb2YgdGhlIFVUWE8uIERlZmF1bHQgMVxuICAgICAqIEBwYXJhbSB0eGlkIE9wdGlvbmFsIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRyYW5zYWN0aW9uIElEIGZvciB0aGUgU3RhbmRhcmRVVFhPXG4gICAgICogQHBhcmFtIHR4aWR4IE9wdGlvbmFsIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9yIG51bWJlciBmb3IgdGhlIGluZGV4IG9mIHRoZSB0cmFuc2FjdGlvbidzIFtbT3V0cHV0XV1cbiAgICAgKiBAcGFyYW0gYXNzZXRpZCBPcHRpb25hbCB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvZiB0aGUgYXNzZXQgSUQgZm9yIHRoZSBTdGFuZGFyZFVUWE9cbiAgICAgKiBAcGFyYW0gb3V0cHV0aWQgT3B0aW9uYWwge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgbnVtYmVyIG9mIHRoZSBvdXRwdXQgSUQgZm9yIHRoZSBTdGFuZGFyZFVUWE9cbiAgICAgKi9cbiAgY29uc3RydWN0b3IoY29kZWNJRDpudW1iZXIgPSAwLCB0eGlkOkJ1ZmZlciA9IHVuZGVmaW5lZCxcbiAgICBvdXRwdXRpZHg6QnVmZmVyIHwgbnVtYmVyID0gdW5kZWZpbmVkLFxuICAgIGFzc2V0aWQ6QnVmZmVyID0gdW5kZWZpbmVkLFxuICAgIG91dHB1dDpPdXRwdXQgPSB1bmRlZmluZWQpe1xuICAgIHN1cGVyKCk7XG4gICAgaWYgKHR5cGVvZiBjb2RlY0lEICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5jb2RlY2lkIC53cml0ZVVJbnQ4KGNvZGVjSUQsIDApO1xuICAgIH1cbiAgICBpZih0eXBlb2YgdHhpZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMudHhpZCA9IHR4aWQ7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3V0cHV0aWR4ID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5vdXRwdXRpZHgud3JpdGVVSW50MzJCRShvdXRwdXRpZHgsIDApO1xuICAgIH0gZWxzZSBpZiAob3V0cHV0aWR4IGluc3RhbmNlb2YgQnVmZmVyKSB7XG4gICAgICB0aGlzLm91dHB1dGlkeCA9IG91dHB1dGlkeDtcbiAgICB9IFxuXG4gICAgaWYodHlwZW9mIGFzc2V0aWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLmFzc2V0aWQgPSBhc3NldGlkO1xuICAgIH1cbiAgICBpZih0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XG4gICAgfVxuICAgICAgXG4gIH1cbn1cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgc2V0IG9mIFtbU3RhbmRhcmRVVFhPXV1zLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgU3RhbmRhcmRVVFhPU2V0PFVUWE9DbGFzcyBleHRlbmRzIFN0YW5kYXJkVVRYTz4gZXh0ZW5kcyBTZXJpYWxpemFibGV7XG4gIHByb3RlY3RlZCBfdHlwZU5hbWUgPSBcIlN0YW5kYXJkVVRYT1NldFwiO1xuICBwcm90ZWN0ZWQgX3R5cGVJRCA9IHVuZGVmaW5lZDtcblxuICBzZXJpYWxpemUoZW5jb2Rpbmc6U2VyaWFsaXplZEVuY29kaW5nID0gXCJoZXhcIik6b2JqZWN0IHtcbiAgICBsZXQgZmllbGRzOm9iamVjdCA9IHN1cGVyLnNlcmlhbGl6ZShlbmNvZGluZyk7XG4gICAgbGV0IHV0eG9zID0ge307XG4gICAgZm9yKGxldCB1dHhvaWQgaW4gdGhpcy51dHhvcykge1xuICAgICAgbGV0IHV0eG9pZENsZWFuZWQ6c3RyaW5nID0gc2VyaWFsaXplci5lbmNvZGVyKHV0eG9pZCwgZW5jb2RpbmcsIFwiYmFzZTU4XCIsIFwiYmFzZTU4XCIpO1xuICAgICAgdXR4b3NbdXR4b2lkQ2xlYW5lZF0gPSB0aGlzLnV0eG9zW3V0eG9pZF0uc2VyaWFsaXplKGVuY29kaW5nKTtcbiAgICB9XG4gICAgbGV0IGFkZHJlc3NVVFhPcyA9IHt9O1xuICAgIGZvcihsZXQgYWRkcmVzcyBpbiB0aGlzLmFkZHJlc3NVVFhPcykge1xuICAgICAgbGV0IGFkZHJlc3NDbGVhbmVkOnN0cmluZyA9IHNlcmlhbGl6ZXIuZW5jb2RlcihhZGRyZXNzLCBlbmNvZGluZywgXCJoZXhcIiwgXCJjYjU4XCIpO1xuICAgICAgbGV0IHV0eG9iYWxhbmNlID0ge307XG4gICAgICBmb3IobGV0IHV0eG9pZCBpbiB0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzXSl7XG4gICAgICAgIGxldCB1dHhvaWRDbGVhbmVkOnN0cmluZyA9IHNlcmlhbGl6ZXIuZW5jb2Rlcih1dHhvaWQsIGVuY29kaW5nLCBcImJhc2U1OFwiLCBcImJhc2U1OFwiKTtcbiAgICAgICAgdXR4b2JhbGFuY2VbdXR4b2lkQ2xlYW5lZF0gPSBzZXJpYWxpemVyLmVuY29kZXIodGhpcy5hZGRyZXNzVVRYT3NbYWRkcmVzc11bdXR4b2lkXSwgZW5jb2RpbmcsIFwiQk5cIiwgXCJkZWNpbWFsU3RyaW5nXCIpO1xuICAgICAgfVxuICAgICAgYWRkcmVzc1VUWE9zW2FkZHJlc3NDbGVhbmVkXSA9IHV0eG9iYWxhbmNlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZmllbGRzLFxuICAgICAgdXR4b3MsXG4gICAgICBhZGRyZXNzVVRYT3NcbiAgICB9XG4gIH07XG5cbiAgcHJvdGVjdGVkIHV0eG9zOntbdXR4b2lkOiBzdHJpbmddOiBVVFhPQ2xhc3MgfSA9IHt9O1xuICBwcm90ZWN0ZWQgYWRkcmVzc1VUWE9zOntbYWRkcmVzczogc3RyaW5nXToge1t1dHhvaWQ6IHN0cmluZ106IEJOfX0gPSB7fTsgLy8gbWFwcyBhZGRyZXNzIHRvIHV0eG9pZHM6bG9ja3RpbWVcblxuICBhYnN0cmFjdCBwYXJzZVVUWE8odXR4bzpVVFhPQ2xhc3MgfCBzdHJpbmcpOlVUWE9DbGFzcztcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBbW1N0YW5kYXJkVVRYT11dIGlzIGluIHRoZSBTdGFuZGFyZFVUWE9TZXQuXG4gICAqXG4gICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbU3RhbmRhcmRVVFhPXV0gYSBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIFN0YW5kYXJkVVRYT1xuICAgKi9cbiAgaW5jbHVkZXMgPSAodXR4bzpVVFhPQ2xhc3MgfCBzdHJpbmcpOmJvb2xlYW4gPT4ge1xuICAgIGxldCB1dHhvWDpVVFhPQ2xhc3MgPSB1bmRlZmluZWQ7XG4gICAgbGV0IHV0eG9pZDpzdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHV0eG9YID0gdGhpcy5wYXJzZVVUWE8odXR4byk7XG4gICAgICB1dHhvaWQgPSB1dHhvWC5nZXRVVFhPSUQoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGlmKGUgaW5zdGFuY2VvZiBFcnJvcil7XG4gICAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSk7XG4gICAgICB9IGVsc2V7IFxuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuICh1dHhvaWQgaW4gdGhpcy51dHhvcyk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogQWRkcyBhIFtbU3RhbmRhcmRVVFhPXV0gdG8gdGhlIFN0YW5kYXJkVVRYT1NldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbU3RhbmRhcmRVVFhPXV0gYW4gY2I1OCBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgYSBTdGFuZGFyZFVUWE9cbiAgICAgKiBAcGFyYW0gb3ZlcndyaXRlIElmIHRydWUsIGlmIHRoZSBVVFhPSUQgYWxyZWFkeSBleGlzdHMsIG92ZXJ3cml0ZSBpdC4uLiBkZWZhdWx0IGZhbHNlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIFtbU3RhbmRhcmRVVFhPXV0gaWYgb25lIHdhcyBhZGRlZCBhbmQgdW5kZWZpbmVkIGlmIG5vdGhpbmcgd2FzIGFkZGVkLlxuICAgICAqL1xuICBhZGQodXR4bzpVVFhPQ2xhc3MgfCBzdHJpbmcsIG92ZXJ3cml0ZTpib29sZWFuID0gZmFsc2UpOlVUWE9DbGFzcyB7XG4gICAgbGV0IHV0eG92YXI6VVRYT0NsYXNzID0gdW5kZWZpbmVkO1xuICAgIHRyeSB7XG4gICAgICB1dHhvdmFyID0gdGhpcy5wYXJzZVVUWE8odXR4byk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBpZihlIGluc3RhbmNlb2YgRXJyb3Ipe1xuICAgICAgICBjb25zb2xlLmxvZyhlLm1lc3NhZ2UpO1xuICAgICAgfSBlbHNleyBcbiAgICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkOyBcbiAgICB9XG5cbiAgICBjb25zdCB1dHhvaWQ6c3RyaW5nID0gdXR4b3Zhci5nZXRVVFhPSUQoKTtcbiAgICBpZiAoISh1dHhvaWQgaW4gdGhpcy51dHhvcykgfHwgb3ZlcndyaXRlID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnV0eG9zW3V0eG9pZF0gPSB1dHhvdmFyO1xuICAgICAgY29uc3QgYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSB1dHhvdmFyLmdldE91dHB1dCgpLmdldEFkZHJlc3NlcygpO1xuICAgICAgY29uc3QgbG9ja3RpbWU6Qk4gPSB1dHhvdmFyLmdldE91dHB1dCgpLmdldExvY2t0aW1lKCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFkZHJlc3Nlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhZGRyZXNzOnN0cmluZyA9IGFkZHJlc3Nlc1tpXS50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGlmICghKGFkZHJlc3MgaW4gdGhpcy5hZGRyZXNzVVRYT3MpKSB7XG4gICAgICAgICAgdGhpcy5hZGRyZXNzVVRYT3NbYWRkcmVzc10gPSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZHJlc3NVVFhPc1thZGRyZXNzXVt1dHhvaWRdID0gbG9ja3RpbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXR4b3ZhcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBBZGRzIGFuIGFycmF5IG9mIFtbU3RhbmRhcmRVVFhPXV1zIHRvIHRoZSBbW1N0YW5kYXJkVVRYT1NldF1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG8gRWl0aGVyIGEgW1tTdGFuZGFyZFVUWE9dXSBhbiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIFN0YW5kYXJkVVRYT1xuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdHJ1ZSwgaWYgdGhlIFVUWE9JRCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0Li4uIGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFN0YW5kYXJkVVRYT3Mgd2hpY2ggd2VyZSBhZGRlZC5cbiAgICAgKi9cbiAgYWRkQXJyYXkodXR4b3M6QXJyYXk8c3RyaW5nIHwgVVRYT0NsYXNzPiwgb3ZlcndyaXRlOmJvb2xlYW4gPSBmYWxzZSk6QXJyYXk8U3RhbmRhcmRVVFhPPiB7XG4gICAgY29uc3QgYWRkZWQ6QXJyYXk8VVRYT0NsYXNzPiA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXR4b3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCByZXN1bHQ6VVRYT0NsYXNzID0gdGhpcy5hZGQodXR4b3NbaV0sIG92ZXJ3cml0ZSk7XG4gICAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBhZGRlZC5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhZGRlZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZW1vdmVzIGEgW1tTdGFuZGFyZFVUWE9dXSBmcm9tIHRoZSBbW1N0YW5kYXJkVVRYT1NldF1dIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvIEVpdGhlciBhIFtbU3RhbmRhcmRVVFhPXV0gYW4gY2I1OCBzZXJpYWxpemVkIHN0cmluZyByZXByZXNlbnRpbmcgYSBTdGFuZGFyZFVUWE9cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgW1tTdGFuZGFyZFVUWE9dXSBpZiBpdCB3YXMgcmVtb3ZlZCBhbmQgdW5kZWZpbmVkIGlmIG5vdGhpbmcgd2FzIHJlbW92ZWQuXG4gICAgICovXG4gIHJlbW92ZSA9ICh1dHhvOlVUWE9DbGFzcyB8IHN0cmluZyk6VVRYT0NsYXNzID0+IHtcbiAgICBsZXQgdXR4b3ZhcjpVVFhPQ2xhc3MgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHV0eG92YXIgPSB0aGlzLnBhcnNlVVRYTyh1dHhvKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGlmKGUgaW5zdGFuY2VvZiBFcnJvcil7XG4gICAgICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSk7XG4gICAgICB9IGVsc2V7IFxuICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bmRlZmluZWQ7IFxuICAgIH1cblxuICAgIGNvbnN0IHV0eG9pZDpzdHJpbmcgPSB1dHhvdmFyLmdldFVUWE9JRCgpO1xuICAgIGlmICghKHV0eG9pZCBpbiB0aGlzLnV0eG9zKSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMudXR4b3NbdXR4b2lkXTtcbiAgICBjb25zdCBhZGRyZXNzZXMgPSBPYmplY3Qua2V5cyh0aGlzLmFkZHJlc3NVVFhPcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhZGRyZXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh1dHhvaWQgaW4gdGhpcy5hZGRyZXNzVVRYT3NbYWRkcmVzc2VzW2ldXSkge1xuICAgICAgICBkZWxldGUgdGhpcy5hZGRyZXNzVVRYT3NbYWRkcmVzc2VzW2ldXVt1dHhvaWRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdXR4b3ZhcjtcbiAgfTtcblxuICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGFycmF5IG9mIFtbU3RhbmRhcmRVVFhPXV1zIHRvIHRoZSBbW1N0YW5kYXJkVVRYT1NldF1dLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG8gRWl0aGVyIGEgW1tTdGFuZGFyZFVUWE9dXSBhbiBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5nIHJlcHJlc2VudGluZyBhIFN0YW5kYXJkVVRYT1xuICAgICAqIEBwYXJhbSBvdmVyd3JpdGUgSWYgdHJ1ZSwgaWYgdGhlIFVUWE9JRCBhbHJlYWR5IGV4aXN0cywgb3ZlcndyaXRlIGl0Li4uIGRlZmF1bHQgZmFsc2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIFVUWE9zIHdoaWNoIHdlcmUgcmVtb3ZlZC5cbiAgICAgKi9cbiAgcmVtb3ZlQXJyYXkgPSAodXR4b3M6QXJyYXk8c3RyaW5nIHwgVVRYT0NsYXNzPik6QXJyYXk8VVRYT0NsYXNzPiA9PiB7XG4gICAgY29uc3QgcmVtb3ZlZDpBcnJheTxVVFhPQ2xhc3M+ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcmVzdWx0OlVUWE9DbGFzcyA9IHRoaXMucmVtb3ZlKHV0eG9zW2ldKTtcbiAgICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZW1vdmVkLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlbW92ZWQ7XG4gIH07XG5cbiAgLyoqXG4gICAgICogR2V0cyBhIFtbU3RhbmRhcmRVVFhPXV0gZnJvbSB0aGUgW1tTdGFuZGFyZFVUWE9TZXRdXSBieSBpdHMgVVRYT0lELlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9pZCBTdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBVVFhPSURcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgW1tTdGFuZGFyZFVUWE9dXSBpZiBpdCBleGlzdHMgaW4gdGhlIHNldC5cbiAgICAgKi9cbiAgZ2V0VVRYTyA9ICh1dHhvaWQ6c3RyaW5nKTpVVFhPQ2xhc3MgPT4gdGhpcy51dHhvc1t1dHhvaWRdO1xuXG4gIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBbW1N0YW5kYXJkVVRYT11dcywgb3B0aW9uYWxseSB0aGF0IG1hdGNoIHdpdGggVVRYT0lEcyBpbiBhbiBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9pZHMgQW4gb3B0aW9uYWwgYXJyYXkgb2YgVVRYT0lEcywgcmV0dXJucyBhbGwgW1tTdGFuZGFyZFVUWE9dXXMgaWYgbm90IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBbW1N0YW5kYXJkVVRYT11dcy5cbiAgICAgKi9cbiAgZ2V0QWxsVVRYT3MgPSAodXR4b2lkczpBcnJheTxzdHJpbmc+ID0gdW5kZWZpbmVkKTpBcnJheTxVVFhPQ2xhc3M+ID0+IHtcbiAgICBsZXQgcmVzdWx0czpBcnJheTxVVFhPQ2xhc3M+ID0gW107XG4gICAgaWYgKHR5cGVvZiB1dHhvaWRzICE9PSAndW5kZWZpbmVkJyAmJiBBcnJheS5pc0FycmF5KHV0eG9pZHMpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHV0eG9pZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHV0eG9pZHNbaV0gaW4gdGhpcy51dHhvcyAmJiAhKHV0eG9pZHNbaV0gaW4gcmVzdWx0cykpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy51dHhvc1t1dHhvaWRzW2ldXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0cyA9IE9iamVjdC52YWx1ZXModGhpcy51dHhvcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEdldHMgYWxsIHRoZSBbW1N0YW5kYXJkVVRYT11dcyBhcyBzdHJpbmdzLCBvcHRpb25hbGx5IHRoYXQgbWF0Y2ggd2l0aCBVVFhPSURzIGluIGFuIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9pZHMgQW4gb3B0aW9uYWwgYXJyYXkgb2YgVVRYT0lEcywgcmV0dXJucyBhbGwgW1tTdGFuZGFyZFVUWE9dXXMgaWYgbm90IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBbW1N0YW5kYXJkVVRYT11dcyBhcyBjYjU4IHNlcmlhbGl6ZWQgc3RyaW5ncy5cbiAgICAgKi9cbiAgZ2V0QWxsVVRYT1N0cmluZ3MgPSAodXR4b2lkczpBcnJheTxzdHJpbmc+ID0gdW5kZWZpbmVkKTpBcnJheTxzdHJpbmc+ID0+IHtcbiAgICBjb25zdCByZXN1bHRzOkFycmF5PHN0cmluZz4gPSBbXTtcbiAgICBjb25zdCB1dHhvcyA9IE9iamVjdC5rZXlzKHRoaXMudXR4b3MpO1xuICAgIGlmICh0eXBlb2YgdXR4b2lkcyAhPT0gJ3VuZGVmaW5lZCcgJiYgQXJyYXkuaXNBcnJheSh1dHhvaWRzKSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh1dHhvaWRzW2ldIGluIHRoaXMudXR4b3MpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2godGhpcy51dHhvc1t1dHhvaWRzW2ldXS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHUgb2YgdXR4b3MpIHtcbiAgICAgICAgcmVzdWx0cy5wdXNoKHRoaXMudXR4b3NbdV0udG9TdHJpbmcoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8qKlxuICAgICAqIEdpdmVuIGFuIGFkZHJlc3Mgb3IgYXJyYXkgb2YgYWRkcmVzc2VzLCByZXR1cm5zIGFsbCB0aGUgVVRYT0lEcyBmb3IgdGhvc2UgYWRkcmVzc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBBbiBhcnJheSBvZiBhZGRyZXNzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9c1xuICAgICAqIEBwYXJhbSBzcGVuZGFibGUgSWYgdHJ1ZSwgb25seSByZXRyaWV2ZXMgVVRYT0lEcyB3aG9zZSBsb2NrdGltZSBoYXMgcGFzc2VkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBhZGRyZXNzZXMuXG4gICAgICovXG4gIGdldFVUWE9JRHMgPSAoYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSB1bmRlZmluZWQsIHNwZW5kYWJsZTpib29sZWFuID0gdHJ1ZSk6QXJyYXk8c3RyaW5nPiA9PiB7XG4gICAgaWYgKHR5cGVvZiBhZGRyZXNzZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zdCByZXN1bHRzOkFycmF5PHN0cmluZz4gPSBbXTtcbiAgICAgIGNvbnN0IG5vdzpCTiA9IFVuaXhOb3coKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChhZGRyZXNzZXNbaV0udG9TdHJpbmcoJ2hleCcpIGluIHRoaXMuYWRkcmVzc1VUWE9zKSB7XG4gICAgICAgICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHRoaXMuYWRkcmVzc1VUWE9zW2FkZHJlc3Nlc1tpXS50b1N0cmluZygnaGV4JyldKTtcbiAgICAgICAgICBmb3IgKGNvbnN0IFt1dHhvaWQsIGxvY2t0aW1lXSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICBpZiAoKHJlc3VsdHMuaW5kZXhPZih1dHhvaWQpID09PSAtMVxuICAgICAgICAgICAgJiYgKHNwZW5kYWJsZSAmJiBsb2NrdGltZS5sdGUobm93KSkpXG4gICAgICAgICAgICB8fCAhc3BlbmRhYmxlKSB7XG4gICAgICAgICAgICAgIHJlc3VsdHMucHVzaCh1dHhvaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnV0eG9zKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIHRoZSBhZGRyZXNzZXMgaW4gdGhlIFtbU3RhbmRhcmRVVFhPU2V0XV0gYW5kIHJldHVybnMgYW4gYXJyYXkgb2Yge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0uXG4gICAgICovXG4gIGdldEFkZHJlc3NlcyA9ICgpOkFycmF5PEJ1ZmZlcj4gPT4gT2JqZWN0LmtleXModGhpcy5hZGRyZXNzVVRYT3MpXG4gICAgLm1hcCgoaykgPT4gQnVmZmVyLmZyb20oaywgJ2hleCcpKTtcblxuICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBiYWxhbmNlIG9mIGEgc2V0IG9mIGFkZHJlc3NlcyBpbiB0aGUgU3RhbmRhcmRVVFhPU2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3NlcyBBbiBhcnJheSBvZiBhZGRyZXNzZXNcbiAgICAgKiBAcGFyYW0gYXNzZXRJRCBFaXRoZXIgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSBvciBhbiBjYjU4IHNlcmlhbGl6ZWQgcmVwcmVzZW50YXRpb24gb2YgYW4gQXNzZXRJRFxuICAgICAqIEBwYXJhbSBhc09mIFRoZSB0aW1lc3RhbXAgdG8gdmVyaWZ5IHRoZSB0cmFuc2FjdGlvbiBhZ2FpbnN0IGFzIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIFJldHVybnMgdGhlIHRvdGFsIGJhbGFuY2UgYXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfS5cbiAgICAgKi9cbiAgZ2V0QmFsYW5jZSA9IChhZGRyZXNzZXM6QXJyYXk8QnVmZmVyPiwgYXNzZXRJRDpCdWZmZXJ8c3RyaW5nLCBhc09mOkJOID0gdW5kZWZpbmVkKTpCTiA9PiB7XG4gICAgY29uc3QgdXR4b2lkczpBcnJheTxzdHJpbmc+ID0gdGhpcy5nZXRVVFhPSURzKGFkZHJlc3Nlcyk7XG4gICAgY29uc3QgdXR4b3M6QXJyYXk8U3RhbmRhcmRVVFhPPiA9IHRoaXMuZ2V0QWxsVVRYT3ModXR4b2lkcyk7XG4gICAgbGV0IHNwZW5kOkJOID0gbmV3IEJOKDApO1xuICAgIGxldCBhc3NldDpCdWZmZXI7XG4gICAgaWYgKHR5cGVvZiBhc3NldElEID09PSAnc3RyaW5nJykge1xuICAgICAgYXNzZXQgPSBiaW50b29scy5jYjU4RGVjb2RlKGFzc2V0SUQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NldCA9IGFzc2V0SUQ7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdXR4b3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh1dHhvc1tpXS5nZXRPdXRwdXQoKSBpbnN0YW5jZW9mIFN0YW5kYXJkQW1vdW50T3V0cHV0XG4gICAgICAmJiB1dHhvc1tpXS5nZXRBc3NldElEKCkudG9TdHJpbmcoJ2hleCcpID09PSBhc3NldC50b1N0cmluZygnaGV4JylcbiAgICAgICYmIHV0eG9zW2ldLmdldE91dHB1dCgpLm1lZXRzVGhyZXNob2xkKGFkZHJlc3NlcywgYXNPZikpIHtcbiAgICAgICAgc3BlbmQgPSBzcGVuZC5hZGQoKHV0eG9zW2ldLmdldE91dHB1dCgpIGFzIFN0YW5kYXJkQW1vdW50T3V0cHV0KS5nZXRBbW91bnQoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzcGVuZDtcbiAgfTtcblxuICAvKipcbiAgICAgKiBHZXRzIGFsbCB0aGUgQXNzZXQgSURzLCBvcHRpb25hbGx5IHRoYXQgbWF0Y2ggd2l0aCBBc3NldCBJRHMgaW4gYW4gYXJyYXlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1dHhvaWRzIEFuIG9wdGlvbmFsIGFycmF5IG9mIEFkZHJlc3NlcyBhcyBzdHJpbmcgb3IgQnVmZmVyLCByZXR1cm5zIGFsbCBBc3NldCBJRHMgaWYgbm90IHByb3ZpZGVkXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSByZXByZXNlbnRpbmcgdGhlIEFzc2V0IElEcy5cbiAgICAgKi9cbiAgZ2V0QXNzZXRJRHMgPSAoYWRkcmVzc2VzOkFycmF5PEJ1ZmZlcj4gPSB1bmRlZmluZWQpOkFycmF5PEJ1ZmZlcj4gPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6U2V0PEJ1ZmZlcj4gPSBuZXcgU2V0KCk7XG4gICAgbGV0IHV0eG9pZHM6QXJyYXk8c3RyaW5nPiA9IFtdO1xuICAgIGlmICh0eXBlb2YgYWRkcmVzc2VzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdXR4b2lkcyA9IHRoaXMuZ2V0VVRYT0lEcyhhZGRyZXNzZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1dHhvaWRzID0gdGhpcy5nZXRVVFhPSURzKCk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB1dHhvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodXR4b2lkc1tpXSBpbiB0aGlzLnV0eG9zICYmICEodXR4b2lkc1tpXSBpbiByZXN1bHRzKSkge1xuICAgICAgICByZXN1bHRzLmFkZCh0aGlzLnV0eG9zW3V0eG9pZHNbaV1dLmdldEFzc2V0SUQoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFsuLi5yZXN1bHRzXTtcbiAgfTtcblxuICBhYnN0cmFjdCBjbG9uZSgpOnRoaXM7XG5cbiAgYWJzdHJhY3QgY3JlYXRlKC4uLmFyZ3M6YW55W10pOnRoaXM7XG5cbiAgZmlsdGVyKGFyZ3M6YW55W10sIGxhbWJkYToodXR4bzpVVFhPQ2xhc3MsIC4uLmxhcmdzOmFueVtdKSA9PiBib29sZWFuKTp0aGlzIHtcbiAgICBsZXQgbmV3c2V0OnRoaXMgPSB0aGlzLmNsb25lKCk7XG4gICAgbGV0IHV0eG9zOkFycmF5PFVUWE9DbGFzcz4gPSB0aGlzLmdldEFsbFVUWE9zKCk7XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IHV0eG9zLmxlbmd0aDsgaSsrKXtcbiAgICAgIGlmKGxhbWJkYSh1dHhvc1tpXSwgLi4uYXJncykgPT09IGZhbHNlKSB7XG4gICAgICAgIG5ld3NldC5yZW1vdmUodXR4b3NbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3c2V0O1xuICB9XG5cbiAgLyoqXG4gICAgICogUmV0dXJucyBhIG5ldyBzZXQgd2l0aCBjb3B5IG9mIFVUWE9zIGluIHRoaXMgYW5kIHNldCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgW1tTdGFuZGFyZFVUWE9TZXRdXSB0byBtZXJnZSB3aXRoIHRoaXMgb25lXG4gICAgICogQHBhcmFtIGhhc1VUWE9JRHMgV2lsbCBzdWJzZWxlY3QgYSBzZXQgb2YgW1tTdGFuZGFyZFVUWE9dXXMgd2hpY2ggaGF2ZSB0aGUgVVRYT0lEcyBwcm92aWRlZCBpbiB0aGlzIGFycmF5LCBkZWZ1bHRzIHRvIGFsbCBVVFhPc1xuICAgICAqXG4gICAgICogQHJldHVybnMgQSBuZXcgU3RhbmRhcmRVVFhPU2V0IHRoYXQgY29udGFpbnMgYWxsIHRoZSBmaWx0ZXJlZCBlbGVtZW50cy5cbiAgICAgKi9cbiAgbWVyZ2UgPSAodXR4b3NldDp0aGlzLCBoYXNVVFhPSURzOkFycmF5PHN0cmluZz4gPSB1bmRlZmluZWQpOnRoaXMgPT4ge1xuICAgIGNvbnN0IHJlc3VsdHM6dGhpcyA9IHRoaXMuY3JlYXRlKCk7XG4gICAgY29uc3QgdXR4b3MxOkFycmF5PFVUWE9DbGFzcz4gPSB0aGlzLmdldEFsbFVUWE9zKGhhc1VUWE9JRHMpO1xuICAgIGNvbnN0IHV0eG9zMjpBcnJheTxVVFhPQ2xhc3M+ID0gdXR4b3NldC5nZXRBbGxVVFhPcyhoYXNVVFhPSURzKTtcbiAgICBjb25zdCBwcm9jZXNzID0gKHV0eG86VVRYT0NsYXNzKSA9PiB7XG4gICAgICByZXN1bHRzLmFkZCh1dHhvKTtcbiAgICB9O1xuICAgIHV0eG9zMS5mb3JFYWNoKHByb2Nlc3MpO1xuICAgIHV0eG9zMi5mb3JFYWNoKHByb2Nlc3MpO1xuICAgIHJldHVybiByZXN1bHRzIGFzIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2V0IGludGVyc2V0aW9uIGJldHdlZW4gdGhpcyBzZXQgYW5kIGEgcGFyYW1ldGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHV0eG9zZXQgVGhlIHNldCB0byBpbnRlcnNlY3RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFN0YW5kYXJkVVRYT1NldCBjb250YWluaW5nIHRoZSBpbnRlcnNlY3Rpb25cbiAgICAgKi9cbiAgaW50ZXJzZWN0aW9uID0gKHV0eG9zZXQ6dGhpcyk6dGhpcyA9PiB7XG4gICAgY29uc3QgdXMxOkFycmF5PHN0cmluZz4gPSB0aGlzLmdldFVUWE9JRHMoKTtcbiAgICBjb25zdCB1czI6QXJyYXk8c3RyaW5nPiA9IHV0eG9zZXQuZ2V0VVRYT0lEcygpO1xuICAgIGNvbnN0IHJlc3VsdHM6QXJyYXk8c3RyaW5nPiA9IHVzMS5maWx0ZXIoKHV0eG9pZCkgPT4gdXMyLmluY2x1ZGVzKHV0eG9pZCkpO1xuICAgIHJldHVybiB0aGlzLm1lcmdlKHV0eG9zZXQsIHJlc3VsdHMpIGFzIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2V0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIHNldCBhbmQgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIGRpZmZlcmVuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFN0YW5kYXJkVVRYT1NldCBjb250YWluaW5nIHRoZSBkaWZmZXJlbmNlXG4gICAgICovXG4gIGRpZmZlcmVuY2UgPSAodXR4b3NldDp0aGlzKTp0aGlzID0+IHtcbiAgICBjb25zdCB1czE6QXJyYXk8c3RyaW5nPiA9IHRoaXMuZ2V0VVRYT0lEcygpO1xuICAgIGNvbnN0IHVzMjpBcnJheTxzdHJpbmc+ID0gdXR4b3NldC5nZXRVVFhPSURzKCk7XG4gICAgY29uc3QgcmVzdWx0czpBcnJheTxzdHJpbmc+ID0gdXMxLmZpbHRlcigodXR4b2lkKSA9PiAhdXMyLmluY2x1ZGVzKHV0eG9pZCkpO1xuICAgIHJldHVybiB0aGlzLm1lcmdlKHV0eG9zZXQsIHJlc3VsdHMpIGFzIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAgICogU2V0IHN5bW1ldHJpY2FsIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGlzIHNldCBhbmQgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIHN5bW1ldHJpY2FsIGRpZmZlcmVuY2VcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEEgbmV3IFN0YW5kYXJkVVRYT1NldCBjb250YWluaW5nIHRoZSBzeW1tZXRyaWNhbCBkaWZmZXJlbmNlXG4gICAgICovXG4gIHN5bURpZmZlcmVuY2UgPSAodXR4b3NldDp0aGlzKTp0aGlzID0+IHtcbiAgICBjb25zdCB1czE6QXJyYXk8c3RyaW5nPiA9IHRoaXMuZ2V0VVRYT0lEcygpO1xuICAgIGNvbnN0IHVzMjpBcnJheTxzdHJpbmc+ID0gdXR4b3NldC5nZXRVVFhPSURzKCk7XG4gICAgY29uc3QgcmVzdWx0czpBcnJheTxzdHJpbmc+ID0gdXMxLmZpbHRlcigodXR4b2lkKSA9PiAhdXMyLmluY2x1ZGVzKHV0eG9pZCkpXG4gICAgICAuY29uY2F0KHVzMi5maWx0ZXIoKHV0eG9pZCkgPT4gIXVzMS5pbmNsdWRlcyh1dHhvaWQpKSk7XG4gICAgcmV0dXJuIHRoaXMubWVyZ2UodXR4b3NldCwgcmVzdWx0cykgYXMgdGhpcztcbiAgfTtcblxuICAvKipcbiAgICAgKiBTZXQgdW5pb24gYmV0d2VlbiB0aGlzIHNldCBhbmQgYSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIHVuaW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBTdGFuZGFyZFVUWE9TZXQgY29udGFpbmluZyB0aGUgdW5pb25cbiAgICAgKi9cbiAgdW5pb24gPSAodXR4b3NldDp0aGlzKTp0aGlzID0+IHRoaXMubWVyZ2UodXR4b3NldCkgYXMgdGhpcztcblxuICAvKipcbiAgICAgKiBNZXJnZXMgYSBzZXQgYnkgdGhlIHJ1bGUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXR4b3NldCBUaGUgc2V0IHRvIG1lcmdlIGJ5IHRoZSBNZXJnZVJ1bGVcbiAgICAgKiBAcGFyYW0gbWVyZ2VSdWxlIFRoZSBbW01lcmdlUnVsZV1dIHRvIGFwcGx5XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIG5ldyBTdGFuZGFyZFVUWE9TZXQgY29udGFpbmluZyB0aGUgbWVyZ2VkIGRhdGFcbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICogVGhlIG1lcmdlIHJ1bGVzIGFyZSBhcyBmb2xsb3dzOlxuICAgICAqICAgKiBcImludGVyc2VjdGlvblwiIC0gdGhlIGludGVyc2VjdGlvbiBvZiB0aGUgc2V0XG4gICAgICogICAqIFwiZGlmZmVyZW5jZVNlbGZcIiAtIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIGV4aXN0aW5nIGRhdGEgYW5kIG5ldyBzZXRcbiAgICAgKiAgICogXCJkaWZmZXJlbmNlTmV3XCIgLSB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBuZXcgZGF0YSBhbmQgdGhlIGV4aXN0aW5nIHNldFxuICAgICAqICAgKiBcInN5bURpZmZlcmVuY2VcIiAtIHRoZSB1bmlvbiBvZiB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBib3RoIHNldHMgb2YgZGF0YVxuICAgICAqICAgKiBcInVuaW9uXCIgLSB0aGUgdW5pcXVlIHNldCBvZiBhbGwgZWxlbWVudHMgY29udGFpbmVkIGluIGJvdGggc2V0c1xuICAgICAqICAgKiBcInVuaW9uTWludXNOZXdcIiAtIHRoZSB1bmlxdWUgc2V0IG9mIGFsbCBlbGVtZW50cyBjb250YWluZWQgaW4gYm90aCBzZXRzLCBleGNsdWRpbmcgdmFsdWVzIG9ubHkgZm91bmQgaW4gdGhlIG5ldyBzZXRcbiAgICAgKiAgICogXCJ1bmlvbk1pbnVzU2VsZlwiIC0gdGhlIHVuaXF1ZSBzZXQgb2YgYWxsIGVsZW1lbnRzIGNvbnRhaW5lZCBpbiBib3RoIHNldHMsIGV4Y2x1ZGluZyB2YWx1ZXMgb25seSBmb3VuZCBpbiB0aGUgZXhpc3Rpbmcgc2V0XG4gICAgICovXG4gIG1lcmdlQnlSdWxlID0gKHV0eG9zZXQ6dGhpcywgbWVyZ2VSdWxlOk1lcmdlUnVsZSk6dGhpcyA9PiB7XG4gICAgbGV0IHVTZXQ6dGhpcztcbiAgICBzd2l0Y2ggKG1lcmdlUnVsZSkge1xuICAgICAgY2FzZSAnaW50ZXJzZWN0aW9uJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uKHV0eG9zZXQpO1xuICAgICAgY2FzZSAnZGlmZmVyZW5jZVNlbGYnOlxuICAgICAgICByZXR1cm4gdGhpcy5kaWZmZXJlbmNlKHV0eG9zZXQpO1xuICAgICAgY2FzZSAnZGlmZmVyZW5jZU5ldyc6XG4gICAgICAgIHJldHVybiB1dHhvc2V0LmRpZmZlcmVuY2UodGhpcykgYXMgdGhpcztcbiAgICAgIGNhc2UgJ3N5bURpZmZlcmVuY2UnOlxuICAgICAgICByZXR1cm4gdGhpcy5zeW1EaWZmZXJlbmNlKHV0eG9zZXQpO1xuICAgICAgY2FzZSAndW5pb24nOlxuICAgICAgICByZXR1cm4gdGhpcy51bmlvbih1dHhvc2V0KTtcbiAgICAgIGNhc2UgJ3VuaW9uTWludXNOZXcnOlxuICAgICAgICB1U2V0ID0gdGhpcy51bmlvbih1dHhvc2V0KTtcbiAgICAgICAgcmV0dXJuIHVTZXQuZGlmZmVyZW5jZSh1dHhvc2V0KSBhcyB0aGlzO1xuICAgICAgY2FzZSAndW5pb25NaW51c1NlbGYnOlxuICAgICAgICB1U2V0ID0gdGhpcy51bmlvbih1dHhvc2V0KTtcbiAgICAgICAgcmV0dXJuIHVTZXQuZGlmZmVyZW5jZSh0aGlzKSBhcyB0aGlzO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IE1lcmdlUnVsZUVycm9yKFwiRXJyb3IgLSBTdGFuZGFyZFVUWE9TZXQubWVyZ2VCeVJ1bGU6IGJhZCBNZXJnZVJ1bGVcIik7XG4gICAgfVxuICB9O1xufVxuIl19