"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @packageDocumentation
 * @module Utils-BinTools
 */
const bn_js_1 = __importDefault(require("bn.js"));
const buffer_1 = require("buffer/");
const create_hash_1 = __importDefault(require("create-hash"));
const bech32 = __importStar(require("bech32"));
const base58_1 = require("./base58");
const errors_1 = require("../utils/errors");
const ethers_1 = require("ethers");
/**
 * A class containing tools useful in interacting with binary data cross-platform using
 * nodejs & javascript.
 *
 * This class should never be instantiated directly. Instead,
 * invoke the "BinTools.getInstance()" static * function to grab the singleton
 * instance of the tools.
 *
 * Everything in this library uses
 * the {@link https://github.com/feross/buffer|feross's Buffer class}.
 *
 * ```js
 * const bintools = BinTools.getInstance();
 * let b58str = bintools.bufferToB58(Buffer.from("Wubalubadubdub!"));
 * ```
 */
class BinTools {
    constructor() {
        /**
         * Returns true if meets requirements to parse as an address as Bech32 on X-Chain or P-Chain, otherwise false
         * @param address the string to verify is address
         */
        this.isPrimaryBechAddress = (address) => {
            const parts = address.trim().split('-');
            if (parts.length !== 2) {
                return false;
            }
            try {
                bech32.fromWords(bech32.decode(parts[1]).words);
            }
            catch (err) {
                return false;
            }
            return true;
        };
        /**
           * Produces a string from a {@link https://github.com/feross/buffer|Buffer}
           * representing a string. ONLY USED IN TRANSACTION FORMATTING, ASSUMED LENGTH IS PREPENDED.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to convert to a string
           */
        this.bufferToString = (buff) => this.copyFrom(buff, 2).toString('utf8');
        /**
           * Produces a {@link https://github.com/feross/buffer|Buffer} from a string. ONLY USED IN TRANSACTION FORMATTING, LENGTH IS PREPENDED.
           *
           * @param str The string to convert to a {@link https://github.com/feross/buffer|Buffer}
           */
        this.stringToBuffer = (str) => {
            const buff = buffer_1.Buffer.alloc(2 + str.length);
            buff.writeUInt16BE(str.length, 0);
            buff.write(str, 2, str.length, 'utf8');
            return buff;
        };
        /**
           * Makes a copy (no reference) of a {@link https://github.com/feross/buffer|Buffer}
           * over provided indecies.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to copy
           * @param start The index to start the copy
           * @param end The index to end the copy
           */
        this.copyFrom = (buff, start = 0, end = undefined) => {
            if (end === undefined) {
                end = buff.length;
            }
            return buffer_1.Buffer.from(Uint8Array.prototype.slice.call(buff.slice(start, end)));
        };
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} and returns a base-58 string of
           * the {@link https://github.com/feross/buffer|Buffer}.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to convert to base-58
           */
        this.bufferToB58 = (buff) => this.b58.encode(buff);
        /**
           * Takes a base-58 string and returns a {@link https://github.com/feross/buffer|Buffer}.
           *
           * @param b58str The base-58 string to convert
           * to a {@link https://github.com/feross/buffer|Buffer}
           */
        this.b58ToBuffer = (b58str) => this.b58.decode(b58str);
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} and returns an ArrayBuffer.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to
           * convert to an ArrayBuffer
           */
        this.fromBufferToArrayBuffer = (buff) => {
            const ab = new ArrayBuffer(buff.length);
            const view = new Uint8Array(ab);
            for (let i = 0; i < buff.length; ++i) {
                view[i] = buff[i];
            }
            return view;
        };
        /**
           * Takes an ArrayBuffer and converts it to a {@link https://github.com/feross/buffer|Buffer}.
           *
           * @param ab The ArrayBuffer to convert to a {@link https://github.com/feross/buffer|Buffer}
           */
        this.fromArrayBufferToBuffer = (ab) => {
            const buf = buffer_1.Buffer.alloc(ab.byteLength);
            for (let i = 0; i < ab.byteLength; ++i) {
                buf[i] = ab[i];
            }
            return buf;
        };
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} and converts it
           * to a {@link https://github.com/indutny/bn.js/|BN}.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to convert
           * to a {@link https://github.com/indutny/bn.js/|BN}
           */
        this.fromBufferToBN = (buff) => {
            if (typeof buff === "undefined") {
                return undefined;
            }
            return new bn_js_1.default(buff.toString('hex'), 16, 'be');
        };
        /**
         * Takes a {@link https://github.com/indutny/bn.js/|BN} and converts it
         * to a {@link https://github.com/feross/buffer|Buffer}.
         *
         * @param bn The {@link https://github.com/indutny/bn.js/|BN} to convert
         * to a {@link https://github.com/feross/buffer|Buffer}
         * @param length The zero-padded length of the {@link https://github.com/feross/buffer|Buffer}
         */
        this.fromBNToBuffer = (bn, length) => {
            if (typeof bn === "undefined") {
                return undefined;
            }
            const newarr = bn.toArray('be');
            /**
             * CKC: Still unsure why bn.toArray with a "be" and a length do not work right. Bug?
             */
            if (length) { // bn toArray with the length parameter doesn't work correctly, need this.
                const x = length - newarr.length;
                for (let i = 0; i < x; i++) {
                    newarr.unshift(0);
                }
            }
            return buffer_1.Buffer.from(newarr);
        };
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} and adds a checksum, returning
           * a {@link https://github.com/feross/buffer|Buffer} with the 4-byte checksum appended.
           *
           * @param buff The {@link https://github.com/feross/buffer|Buffer} to append a checksum
           */
        this.addChecksum = (buff) => {
            const hashslice = buffer_1.Buffer.from(create_hash_1.default('sha256').update(buff).digest().slice(28));
            return buffer_1.Buffer.concat([buff, hashslice]);
        };
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} with an appended 4-byte checksum
           * and returns true if the checksum is valid, otherwise false.
           *
           * @param b The {@link https://github.com/feross/buffer|Buffer} to validate the checksum
           */
        this.validateChecksum = (buff) => {
            const checkslice = buff.slice(buff.length - 4);
            const hashslice = buffer_1.Buffer.from(create_hash_1.default('sha256').update(buff.slice(0, buff.length - 4)).digest().slice(28));
            return checkslice.toString('hex') === hashslice.toString('hex');
        };
        /**
           * Takes a {@link https://github.com/feross/buffer|Buffer} and returns a base-58 string with
           * checksum as per the cb58 standard.
           *
           * @param bytes A {@link https://github.com/feross/buffer|Buffer} to serialize
           *
           * @returns A serialized base-58 string of the Buffer.
           */
        this.cb58Encode = (bytes) => {
            const x = this.addChecksum(bytes);
            return this.bufferToB58(x);
        };
        /**
           * Takes a cb58 serialized {@link https://github.com/feross/buffer|Buffer} or base-58 string
           * and returns a {@link https://github.com/feross/buffer|Buffer} of the original data. Throws on error.
           *
           * @param bytes A cb58 serialized {@link https://github.com/feross/buffer|Buffer} or base-58 string
           */
        this.cb58Decode = (bytes) => {
            if (typeof bytes === 'string') {
                bytes = this.b58ToBuffer(bytes);
            }
            if (this.validateChecksum(bytes)) {
                return this.copyFrom(bytes, 0, bytes.length - 4);
            }
            throw new errors_1.ChecksumError('Error - BinTools.cb58Decode: invalid checksum');
        };
        this.addressToString = (hrp, chainid, bytes) => `${chainid}-${bech32.encode(hrp, bech32.toWords(bytes))}`;
        this.stringToAddress = (address, hrp) => {
            if (address.substring(0, 2) === "0x") {
                // ETH-style address
                if (ethers_1.utils.isAddress(address)) {
                    return buffer_1.Buffer.from(address.substring(2), "hex");
                }
                else {
                    throw new errors_1.HexError('Error - Invalid address');
                }
            }
            // Bech32 addresses
            const parts = address.trim().split('-');
            if (parts.length < 2) {
                throw new errors_1.Bech32Error('Error - Valid address should include -');
            }
            if (parts[0].length < 1) {
                throw new errors_1.Bech32Error('Error - Valid address must have prefix before -');
            }
            const split = parts[1].lastIndexOf('1');
            if (split < 0) {
                throw new errors_1.Bech32Error('Error - Valid address must include separator (1)');
            }
            const humanReadablePart = parts[1].slice(0, split);
            if (humanReadablePart.length < 1) {
                throw new errors_1.Bech32Error('Error - HRP should be at least 1 character');
            }
            if (humanReadablePart !== 'avax' && humanReadablePart !== 'fuji' && humanReadablePart != 'local' && humanReadablePart != hrp) {
                throw new errors_1.Bech32Error('Error - Invalid HRP');
            }
            return buffer_1.Buffer.from(bech32.fromWords(bech32.decode(parts[1]).words));
        };
        /**
         * Takes an address and returns its {@link https://github.com/feross/buffer|Buffer}
         * representation if valid. A more strict version of stringToAddress.
         *
         * @param addr A string representation of the address
         * @param blockchainID A cb58 encoded string representation of the blockchainID
         * @param alias A chainID alias, if any, that the address can also parse from.
         * @param addrlen VMs can use any addressing scheme that they like, so this is the appropriate number of address bytes. Default 20.
         *
         * @returns A {@link https://github.com/feross/buffer|Buffer} for the address if valid,
         * undefined if not valid.
         */
        this.parseAddress = (addr, blockchainID, alias = undefined, addrlen = 20) => {
            const abc = addr.split('-');
            if (abc.length === 2 && ((alias && abc[0] === alias) || (blockchainID && abc[0] === blockchainID))) {
                const addrbuff = this.stringToAddress(addr);
                if ((addrlen && addrbuff.length === addrlen) || !(addrlen)) {
                    return addrbuff;
                }
            }
            return undefined;
        };
        this.b58 = base58_1.Base58.getInstance();
    }
    /**
     * Retrieves the BinTools singleton.
     */
    static getInstance() {
        if (!BinTools.instance) {
            BinTools.instance = new BinTools();
        }
        return BinTools.instance;
    }
    /**
     * Returns true if base64, otherwise false
     * @param str the string to verify is Base64
     */
    isBase64(str) {
        if (str === '' || str.trim() === '') {
            return false;
        }
        try {
            let b64 = buffer_1.Buffer.from(str, "base64");
            return b64.toString("base64") === str;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Returns true if cb58, otherwise false
     * @param cb58 the string to verify is cb58
     */
    isCB58(cb58) {
        return this.isBase58(cb58);
    }
    /**
     * Returns true if base58, otherwise false
     * @param base58 the string to verify is base58
     */
    isBase58(base58) {
        if (base58 === '' || base58.trim() === '') {
            return false;
        }
        try {
            return this.b58.encode(this.b58.decode(base58)) === base58;
        }
        catch (err) {
            return false;
        }
    }
    /**
     * Returns true if hexidecimal, otherwise false
     * @param hex the string to verify is hexidecimal
     */
    isHex(hex) {
        if (hex === '' || hex.trim() === '') {
            return false;
        }
        if ((hex.startsWith("0x") && hex.slice(2).match(/^[0-9A-Fa-f]/g) || hex.match(/^[0-9A-Fa-f]/g))) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Returns true if decimal, otherwise false
     * @param str the string to verify is hexidecimal
     */
    isDecimal(str) {
        if (str === '' || str.trim() === '') {
            return false;
        }
        try {
            return new bn_js_1.default(str, 10).toString(10) === str.trim();
        }
        catch (err) {
            return false;
        }
    }
}
exports.default = BinTools;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmludG9vbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvdXRpbHMvYmludG9vbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7OztHQUdHO0FBQ0gsa0RBQXVCO0FBQ3ZCLG9DQUFpQztBQUNqQyw4REFBcUM7QUFDckMsK0NBQWlDO0FBQ2pDLHFDQUFrQztBQUVsQyw0Q0FBdUU7QUFDdkUsbUNBQStCO0FBRS9COzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUNILE1BQXFCLFFBQVE7SUFHM0I7UUE2RUE7OztXQUdHO1FBQ0gseUJBQW9CLEdBQUcsQ0FBQyxPQUFjLEVBQVUsRUFBRTtZQUNoRCxNQUFNLEtBQUssR0FBaUIsT0FBTyxDQUFDLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUN0RCxJQUFHLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO2dCQUNyQixPQUFPLEtBQUssQ0FBQzthQUNkO1lBQ0QsSUFBSTtnQkFDRixNQUFNLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDakQ7WUFBQyxPQUFNLEdBQUcsRUFBRTtnQkFDWCxPQUFPLEtBQUssQ0FBQTthQUNiO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUM7UUFHRjs7Ozs7YUFLSztRQUNMLG1CQUFjLEdBQUcsQ0FBQyxJQUFXLEVBQVMsRUFBRSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxFQUFFLENBQUMsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUVqRjs7OzthQUlLO1FBQ0wsbUJBQWMsR0FBRyxDQUFDLEdBQVUsRUFBUyxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxHQUFVLGVBQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxHQUFHLEdBQUcs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QUFDLEVBQUU7WUFDL0YsT0FBTyxJQUFJLENBQUE7U0FDWjthQUFNO1lBQ0wsT0FBTyxLQUFLLENBQUE7U0FDYjtJQUNILENBQUM7SUFFRDs7O09BR0c7SUFDSCxTQUFTLENBQUMsR0FBVTtRQUNsQixJQUFJLEdBQUcsS0FBSSxFQUFFLElBQUksR0FBRyxDQUFDLElBQUksRUFBRSxLQUFJLEVBQUUsRUFBQztZQUFFLE9BQU8sS0FBSyxDQUFDO1NBQUU7UUFDbkQsSUFBSTtZQUNGLE9BQU8sSUFBSSxlQUFFLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsS0FBSyxHQUFHLENBQUMsSUFBSSxFQUFFLENBQUM7U0FDcEQ7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNWLE9BQU8sS0FBSyxDQUFDO1NBQ2hCO0lBQ0gsQ0FBQztDQTZQRjtBQTNVRCwyQkEyVUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBVdGlscy1CaW5Ub29sc1xuICovXG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyLyc7XG5pbXBvcnQgY3JlYXRlSGFzaCBmcm9tICdjcmVhdGUtaGFzaCc7XG5pbXBvcnQgKiBhcyBiZWNoMzIgZnJvbSAnYmVjaDMyJztcbmltcG9ydCB7IEJhc2U1OCB9IGZyb20gJy4vYmFzZTU4JztcbmltcG9ydCB7IERlZmF1bHRzIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQmVjaDMyRXJyb3IsIENoZWNrc3VtRXJyb3IsIEhleEVycm9yIH0gZnJvbSAnLi4vdXRpbHMvZXJyb3JzJztcbmltcG9ydCB7IHV0aWxzIH0gZnJvbSBcImV0aGVyc1wiO1xuXG4vKipcbiAqIEEgY2xhc3MgY29udGFpbmluZyB0b29scyB1c2VmdWwgaW4gaW50ZXJhY3Rpbmcgd2l0aCBiaW5hcnkgZGF0YSBjcm9zcy1wbGF0Zm9ybSB1c2luZ1xuICogbm9kZWpzICYgamF2YXNjcmlwdC5cbiAqXG4gKiBUaGlzIGNsYXNzIHNob3VsZCBuZXZlciBiZSBpbnN0YW50aWF0ZWQgZGlyZWN0bHkuIEluc3RlYWQsXG4gKiBpbnZva2UgdGhlIFwiQmluVG9vbHMuZ2V0SW5zdGFuY2UoKVwiIHN0YXRpYyAqIGZ1bmN0aW9uIHRvIGdyYWIgdGhlIHNpbmdsZXRvblxuICogaW5zdGFuY2Ugb2YgdGhlIHRvb2xzLlxuICpcbiAqIEV2ZXJ5dGhpbmcgaW4gdGhpcyBsaWJyYXJ5IHVzZXNcbiAqIHRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8ZmVyb3NzJ3MgQnVmZmVyIGNsYXNzfS5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYmludG9vbHMgPSBCaW5Ub29scy5nZXRJbnN0YW5jZSgpO1xuICogbGV0IGI1OHN0ciA9IGJpbnRvb2xzLmJ1ZmZlclRvQjU4KEJ1ZmZlci5mcm9tKFwiV3ViYWx1YmFkdWJkdWIhXCIpKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBCaW5Ub29scyB7XG4gIHByaXZhdGUgc3RhdGljIGluc3RhbmNlOkJpblRvb2xzO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5iNTggPSBCYXNlNTguZ2V0SW5zdGFuY2UoKTtcbiAgfVxuXG4gIHByaXZhdGUgYjU4OkJhc2U1ODtcblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBCaW5Ub29scyBzaW5nbGV0b24uXG4gICAqL1xuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKTogQmluVG9vbHMge1xuICAgIGlmICghQmluVG9vbHMuaW5zdGFuY2UpIHtcbiAgICAgIEJpblRvb2xzLmluc3RhbmNlID0gbmV3IEJpblRvb2xzKCk7XG4gICAgfVxuICAgIHJldHVybiBCaW5Ub29scy5pbnN0YW5jZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYmFzZTY0LCBvdGhlcndpc2UgZmFsc2VcbiAgICogQHBhcmFtIHN0ciB0aGUgc3RyaW5nIHRvIHZlcmlmeSBpcyBCYXNlNjRcbiAgICovXG4gIGlzQmFzZTY0KHN0cjpzdHJpbmcpIHtcbiAgICBpZiAoc3RyID09PScnIHx8IHN0ci50cmltKCkgPT09JycpeyByZXR1cm4gZmFsc2U7IH1cbiAgICB0cnkge1xuICAgICAgICBsZXQgYjY0OkJ1ZmZlciA9IEJ1ZmZlci5mcm9tKHN0ciwgXCJiYXNlNjRcIik7XG4gICAgICAgIHJldHVybiBiNjQudG9TdHJpbmcoXCJiYXNlNjRcIikgPT09IHN0cjtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2I1OCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqIEBwYXJhbSBjYjU4IHRoZSBzdHJpbmcgdG8gdmVyaWZ5IGlzIGNiNThcbiAgICovXG4gIGlzQ0I1OChjYjU4OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pc0Jhc2U1OChjYjU4KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBiYXNlNTgsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcGFyYW0gYmFzZTU4IHRoZSBzdHJpbmcgdG8gdmVyaWZ5IGlzIGJhc2U1OFxuICAgKi9cbiAgaXNCYXNlNTgoYmFzZTU4OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBpZiAoYmFzZTU4ID09PSAnJyB8fCBiYXNlNTgudHJpbSgpID09PSAnJykgeyByZXR1cm4gZmFsc2UgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5iNTguZW5jb2RlKHRoaXMuYjU4LmRlY29kZShiYXNlNTgpKSA9PT0gYmFzZTU4O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBoZXhpZGVjaW1hbCwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqIEBwYXJhbSBoZXggdGhlIHN0cmluZyB0byB2ZXJpZnkgaXMgaGV4aWRlY2ltYWxcbiAgICovXG4gIGlzSGV4KGhleDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgaWYgKGhleCA9PT0gJycgfHwgaGV4LnRyaW0oKSA9PT0gJycpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICBpZiAoKGhleC5zdGFydHNXaXRoKFwiMHhcIikgJiYgaGV4LnNsaWNlKDIpLm1hdGNoKC9eWzAtOUEtRmEtZl0vZykgfHwgaGV4Lm1hdGNoKC9eWzAtOUEtRmEtZl0vZykpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGRlY2ltYWwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcGFyYW0gc3RyIHRoZSBzdHJpbmcgdG8gdmVyaWZ5IGlzIGhleGlkZWNpbWFsXG4gICAqL1xuICBpc0RlY2ltYWwoc3RyOnN0cmluZykge1xuICAgIGlmIChzdHIgPT09JycgfHwgc3RyLnRyaW0oKSA9PT0nJyl7IHJldHVybiBmYWxzZTsgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IEJOKHN0ciwgMTApLnRvU3RyaW5nKDEwKSA9PT0gc3RyLnRyaW0oKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgbWVldHMgcmVxdWlyZW1lbnRzIHRvIHBhcnNlIGFzIGFuIGFkZHJlc3MgYXMgQmVjaDMyIG9uIFgtQ2hhaW4gb3IgUC1DaGFpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAqIEBwYXJhbSBhZGRyZXNzIHRoZSBzdHJpbmcgdG8gdmVyaWZ5IGlzIGFkZHJlc3NcbiAgICovXG4gIGlzUHJpbWFyeUJlY2hBZGRyZXNzID0gKGFkZHJlc3M6c3RyaW5nKTpib29sZWFuID0+IHtcbiAgICBjb25zdCBwYXJ0czpBcnJheTxzdHJpbmc+ID0gYWRkcmVzcy50cmltKCkuc3BsaXQoJy0nKTtcbiAgICBpZihwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGJlY2gzMi5mcm9tV29yZHMoYmVjaDMyLmRlY29kZShwYXJ0c1sxXSkud29yZHMpO1xuICAgIH0gY2F0Y2goZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cblxuICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHN0cmluZyBmcm9tIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICAgKiByZXByZXNlbnRpbmcgYSBzdHJpbmcuIE9OTFkgVVNFRCBJTiBUUkFOU0FDVElPTiBGT1JNQVRUSU5HLCBBU1NVTUVEIExFTkdUSCBJUyBQUkVQRU5ERUQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZiBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gdG8gY29udmVydCB0byBhIHN0cmluZ1xuICAgICAqL1xuICBidWZmZXJUb1N0cmluZyA9IChidWZmOkJ1ZmZlcik6c3RyaW5nID0+IHRoaXMuY29weUZyb20oYnVmZiwgMikudG9TdHJpbmcoJ3V0ZjgnKTtcblxuICAvKipcbiAgICAgKiBQcm9kdWNlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZyb20gYSBzdHJpbmcuIE9OTFkgVVNFRCBJTiBUUkFOU0FDVElPTiBGT1JNQVRUSU5HLCBMRU5HVEggSVMgUFJFUEVOREVELlxuICAgICAqXG4gICAgICogQHBhcmFtIHN0ciBUaGUgc3RyaW5nIHRvIGNvbnZlcnQgdG8gYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqL1xuICBzdHJpbmdUb0J1ZmZlciA9IChzdHI6c3RyaW5nKTpCdWZmZXIgPT4ge1xuICAgIGNvbnN0IGJ1ZmY6QnVmZmVyID0gQnVmZmVyLmFsbG9jKDIgKyBzdHIubGVuZ3RoKTtcbiAgICBidWZmLndyaXRlVUludDE2QkUoc3RyLmxlbmd0aCwgMCk7XG4gICAgYnVmZi53cml0ZShzdHIsIDIsIHN0ci5sZW5ndGgsICd1dGY4Jyk7XG4gICAgcmV0dXJuIGJ1ZmY7XG4gIH07XG5cbiAgLyoqXG4gICAgICogTWFrZXMgYSBjb3B5IChubyByZWZlcmVuY2UpIG9mIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICAgKiBvdmVyIHByb3ZpZGVkIGluZGVjaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmYgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHRvIGNvcHlcbiAgICAgKiBAcGFyYW0gc3RhcnQgVGhlIGluZGV4IHRvIHN0YXJ0IHRoZSBjb3B5XG4gICAgICogQHBhcmFtIGVuZCBUaGUgaW5kZXggdG8gZW5kIHRoZSBjb3B5XG4gICAgICovXG4gIGNvcHlGcm9tID0gKGJ1ZmY6QnVmZmVyLCBzdGFydDpudW1iZXIgPSAwLCBlbmQ6bnVtYmVyID0gdW5kZWZpbmVkKTpCdWZmZXIgPT4ge1xuICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZW5kID0gYnVmZi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBCdWZmZXIuZnJvbShVaW50OEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ1ZmYuc2xpY2Uoc3RhcnQsIGVuZCkpKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGFuZCByZXR1cm5zIGEgYmFzZS01OCBzdHJpbmcgb2ZcbiAgICAgKiB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZiBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gdG8gY29udmVydCB0byBiYXNlLTU4XG4gICAgICovXG4gIGJ1ZmZlclRvQjU4ID0gKGJ1ZmY6QnVmZmVyKTpzdHJpbmcgPT4gdGhpcy5iNTguZW5jb2RlKGJ1ZmYpO1xuXG4gIC8qKlxuICAgICAqIFRha2VzIGEgYmFzZS01OCBzdHJpbmcgYW5kIHJldHVybnMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBiNThzdHIgVGhlIGJhc2UtNTggc3RyaW5nIHRvIGNvbnZlcnRcbiAgICAgKiB0byBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAgICovXG4gIGI1OFRvQnVmZmVyID0gKGI1OHN0cjpzdHJpbmcpOkJ1ZmZlciA9PiB0aGlzLmI1OC5kZWNvZGUoYjU4c3RyKTtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGFuZCByZXR1cm5zIGFuIEFycmF5QnVmZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmYgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHRvXG4gICAgICogY29udmVydCB0byBhbiBBcnJheUJ1ZmZlclxuICAgICAqL1xuICBmcm9tQnVmZmVyVG9BcnJheUJ1ZmZlciA9IChidWZmOkJ1ZmZlcik6QXJyYXlCdWZmZXIgPT4ge1xuICAgIGNvbnN0IGFiID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmYubGVuZ3RoKTtcbiAgICBjb25zdCB2aWV3ID0gbmV3IFVpbnQ4QXJyYXkoYWIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZi5sZW5ndGg7ICsraSkge1xuICAgICAgdmlld1tpXSA9IGJ1ZmZbaV07XG4gICAgfVxuICAgIHJldHVybiB2aWV3O1xuICB9O1xuXG4gIC8qKlxuICAgICAqIFRha2VzIGFuIEFycmF5QnVmZmVyIGFuZCBjb252ZXJ0cyBpdCB0byBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGFiIFRoZSBBcnJheUJ1ZmZlciB0byBjb252ZXJ0IHRvIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICAgKi9cbiAgZnJvbUFycmF5QnVmZmVyVG9CdWZmZXIgPSAoYWI6QXJyYXlCdWZmZXIpOkJ1ZmZlciA9PiB7XG4gICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jKGFiLmJ5dGVMZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWIuYnl0ZUxlbmd0aDsgKytpKSB7XG4gICAgICBidWZbaV0gPSBhYltpXTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1ZjtcbiAgfTtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGFuZCBjb252ZXJ0cyBpdFxuICAgICAqIHRvIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnVmZiBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gdG8gY29udmVydFxuICAgICAqIHRvIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL3xCTn1cbiAgICAgKi9cbiAgZnJvbUJ1ZmZlclRvQk4gPSAoYnVmZjpCdWZmZXIpOkJOID0+IHtcbiAgICBpZih0eXBlb2YgYnVmZiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCTihidWZmLnRvU3RyaW5nKCdoZXgnKSwgMTYsICdiZScpXG4gIH07XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSBhbmQgY29udmVydHMgaXRcbiAgICAgKiB0byBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9LlxuICAgICAqXG4gICAgICogQHBhcmFtIGJuIFRoZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvfEJOfSB0byBjb252ZXJ0XG4gICAgICogdG8gYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfVxuICAgICAqIEBwYXJhbSBsZW5ndGggVGhlIHplcm8tcGFkZGVkIGxlbmd0aCBvZiB0aGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn1cbiAgICAgKi9cbiAgZnJvbUJOVG9CdWZmZXIgPSAoYm46Qk4sIGxlbmd0aD86bnVtYmVyKTpCdWZmZXIgPT4ge1xuICAgIGlmKHR5cGVvZiBibiA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbmV3YXJyID0gYm4udG9BcnJheSgnYmUnKTtcbiAgICAvKipcbiAgICAgKiBDS0M6IFN0aWxsIHVuc3VyZSB3aHkgYm4udG9BcnJheSB3aXRoIGEgXCJiZVwiIGFuZCBhIGxlbmd0aCBkbyBub3Qgd29yayByaWdodC4gQnVnP1xuICAgICAqL1xuICAgIGlmIChsZW5ndGgpIHsgLy8gYm4gdG9BcnJheSB3aXRoIHRoZSBsZW5ndGggcGFyYW1ldGVyIGRvZXNuJ3Qgd29yayBjb3JyZWN0bHksIG5lZWQgdGhpcy5cbiAgICAgIGNvbnN0IHggPSBsZW5ndGggLSBuZXdhcnIubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaTpudW1iZXIgPSAwOyBpIDwgeDsgaSsrKSB7XG4gICAgICAgIG5ld2Fyci51bnNoaWZ0KDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20obmV3YXJyKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGFuZCBhZGRzIGEgY2hlY2tzdW0sIHJldHVybmluZ1xuICAgICAqIGEge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gd2l0aCB0aGUgNC1ieXRlIGNoZWNrc3VtIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1ZmYgVGhlIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHRvIGFwcGVuZCBhIGNoZWNrc3VtXG4gICAgICovXG4gIGFkZENoZWNrc3VtID0gKGJ1ZmY6QnVmZmVyKTpCdWZmZXIgPT4ge1xuICAgIGNvbnN0IGhhc2hzbGljZTpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmZikuZGlnZXN0KCkuc2xpY2UoMjgpKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbYnVmZiwgaGFzaHNsaWNlXSk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXJ8QnVmZmVyfSB3aXRoIGFuIGFwcGVuZGVkIDQtYnl0ZSBjaGVja3N1bVxuICAgICAqIGFuZCByZXR1cm5zIHRydWUgaWYgdGhlIGNoZWNrc3VtIGlzIHZhbGlkLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYiBUaGUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gdG8gdmFsaWRhdGUgdGhlIGNoZWNrc3VtXG4gICAgICovXG4gIHZhbGlkYXRlQ2hlY2tzdW0gPSAoYnVmZjpCdWZmZXIpOmJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IGNoZWNrc2xpY2U6QnVmZmVyID0gYnVmZi5zbGljZShidWZmLmxlbmd0aCAtIDQpO1xuICAgIGNvbnN0IGhhc2hzbGljZTpCdWZmZXIgPSBCdWZmZXIuZnJvbShjcmVhdGVIYXNoKCdzaGEyNTYnKS51cGRhdGUoYnVmZi5zbGljZSgwLCBidWZmLmxlbmd0aCAtIDQpKS5kaWdlc3QoKS5zbGljZSgyOCkpO1xuICAgIHJldHVybiBjaGVja3NsaWNlLnRvU3RyaW5nKCdoZXgnKSA9PT0gaGFzaHNsaWNlLnRvU3RyaW5nKCdoZXgnKTtcbiAgfTtcblxuICAvKipcbiAgICAgKiBUYWtlcyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGFuZCByZXR1cm5zIGEgYmFzZS01OCBzdHJpbmcgd2l0aFxuICAgICAqIGNoZWNrc3VtIGFzIHBlciB0aGUgY2I1OCBzdGFuZGFyZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBieXRlcyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IHRvIHNlcmlhbGl6ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBzZXJpYWxpemVkIGJhc2UtNTggc3RyaW5nIG9mIHRoZSBCdWZmZXIuXG4gICAgICovXG4gIGNiNThFbmNvZGUgPSAoYnl0ZXM6QnVmZmVyKTpzdHJpbmcgPT4ge1xuICAgIGNvbnN0IHg6QnVmZmVyID0gdGhpcy5hZGRDaGVja3N1bShieXRlcyk7XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyVG9CNTgoeCk7XG4gIH07XG5cbiAgLyoqXG4gICAgICogVGFrZXMgYSBjYjU4IHNlcmlhbGl6ZWQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgYmFzZS01OCBzdHJpbmdcbiAgICAgKiBhbmQgcmV0dXJucyBhIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IG9mIHRoZSBvcmlnaW5hbCBkYXRhLiBUaHJvd3Mgb24gZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYnl0ZXMgQSBjYjU4IHNlcmlhbGl6ZWQge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyfEJ1ZmZlcn0gb3IgYmFzZS01OCBzdHJpbmdcbiAgICAgKi9cbiAgY2I1OERlY29kZSA9IChieXRlczpCdWZmZXIgfCBzdHJpbmcpOkJ1ZmZlciA9PiB7XG4gICAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ5dGVzID0gdGhpcy5iNThUb0J1ZmZlcihieXRlcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZhbGlkYXRlQ2hlY2tzdW0oYnl0ZXMpKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb3B5RnJvbShieXRlcywgMCwgYnl0ZXMubGVuZ3RoIC0gNCk7XG4gICAgfVxuICAgIHRocm93IG5ldyBDaGVja3N1bUVycm9yKCdFcnJvciAtIEJpblRvb2xzLmNiNThEZWNvZGU6IGludmFsaWQgY2hlY2tzdW0nKTtcbiAgfTtcblxuICBhZGRyZXNzVG9TdHJpbmcgPSAoaHJwOiBzdHJpbmcsIGNoYWluaWQ6IHN0cmluZywgYnl0ZXM6IEJ1ZmZlcik6IHN0cmluZyA9PiBgJHtjaGFpbmlkfS0ke2JlY2gzMi5lbmNvZGUoaHJwLCBiZWNoMzIudG9Xb3JkcyhieXRlcykpfWA7XG5cbiAgc3RyaW5nVG9BZGRyZXNzID0gKGFkZHJlc3M6IHN0cmluZywgaHJwPzogc3RyaW5nKTogQnVmZmVyID0+IHtcbiAgICBpZihhZGRyZXNzLnN1YnN0cmluZygwLCAyKSA9PT0gXCIweFwiKSB7XG4gICAgICAvLyBFVEgtc3R5bGUgYWRkcmVzc1xuICAgICAgaWYodXRpbHMuaXNBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShhZGRyZXNzLnN1YnN0cmluZygyLCksIFwiaGV4XCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEhleEVycm9yKCdFcnJvciAtIEludmFsaWQgYWRkcmVzcycpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBCZWNoMzIgYWRkcmVzc2VzXG4gICAgY29uc3QgcGFydHM6IHN0cmluZ1tdID0gYWRkcmVzcy50cmltKCkuc3BsaXQoJy0nKTtcblxuICAgIGlmKHBhcnRzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBCZWNoMzJFcnJvcignRXJyb3IgLSBWYWxpZCBhZGRyZXNzIHNob3VsZCBpbmNsdWRlIC0nKTtcbiAgICB9XG5cbiAgICBpZihwYXJ0c1swXS5sZW5ndGggPCAxKSB7XG4gICAgICB0aHJvdyBuZXcgQmVjaDMyRXJyb3IoJ0Vycm9yIC0gVmFsaWQgYWRkcmVzcyBtdXN0IGhhdmUgcHJlZml4IGJlZm9yZSAtJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgc3BsaXQ6IG51bWJlciA9IHBhcnRzWzFdLmxhc3RJbmRleE9mKCcxJyk7XG4gICAgaWYoc3BsaXQgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgQmVjaDMyRXJyb3IoJ0Vycm9yIC0gVmFsaWQgYWRkcmVzcyBtdXN0IGluY2x1ZGUgc2VwYXJhdG9yICgxKScpO1xuICAgIH1cblxuICAgIGNvbnN0IGh1bWFuUmVhZGFibGVQYXJ0OiBzdHJpbmcgPSBwYXJ0c1sxXS5zbGljZSgwLCBzcGxpdCk7XG4gICAgaWYoaHVtYW5SZWFkYWJsZVBhcnQubGVuZ3RoIDwgMSkge1xuICAgICAgdGhyb3cgbmV3IEJlY2gzMkVycm9yKCdFcnJvciAtIEhSUCBzaG91bGQgYmUgYXQgbGVhc3QgMSBjaGFyYWN0ZXInKTtcbiAgICB9XG5cbiAgICBpZihodW1hblJlYWRhYmxlUGFydCAhPT0gJ2F2YXgnICYmIGh1bWFuUmVhZGFibGVQYXJ0ICE9PSAnZnVqaScgJiYgaHVtYW5SZWFkYWJsZVBhcnQgIT0gJ2xvY2FsJyAmJiBodW1hblJlYWRhYmxlUGFydCAhPSBocnApIHtcbiAgICAgIHRocm93IG5ldyBCZWNoMzJFcnJvcignRXJyb3IgLSBJbnZhbGlkIEhSUCcpO1xuICAgIH1cblxuICAgIHJldHVybiBCdWZmZXIuZnJvbShiZWNoMzIuZnJvbVdvcmRzKGJlY2gzMi5kZWNvZGUocGFydHNbMV0pLndvcmRzKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRha2VzIGFuIGFkZHJlc3MgYW5kIHJldHVybnMgaXRzIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9XG4gICAqIHJlcHJlc2VudGF0aW9uIGlmIHZhbGlkLiBBIG1vcmUgc3RyaWN0IHZlcnNpb24gb2Ygc3RyaW5nVG9BZGRyZXNzLlxuICAgKlxuICAgKiBAcGFyYW0gYWRkciBBIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYWRkcmVzc1xuICAgKiBAcGFyYW0gYmxvY2tjaGFpbklEIEEgY2I1OCBlbmNvZGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgYmxvY2tjaGFpbklEXG4gICAqIEBwYXJhbSBhbGlhcyBBIGNoYWluSUQgYWxpYXMsIGlmIGFueSwgdGhhdCB0aGUgYWRkcmVzcyBjYW4gYWxzbyBwYXJzZSBmcm9tLlxuICAgKiBAcGFyYW0gYWRkcmxlbiBWTXMgY2FuIHVzZSBhbnkgYWRkcmVzc2luZyBzY2hlbWUgdGhhdCB0aGV5IGxpa2UsIHNvIHRoaXMgaXMgdGhlIGFwcHJvcHJpYXRlIG51bWJlciBvZiBhZGRyZXNzIGJ5dGVzLiBEZWZhdWx0IDIwLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIHtAbGluayBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlcnxCdWZmZXJ9IGZvciB0aGUgYWRkcmVzcyBpZiB2YWxpZCxcbiAgICogdW5kZWZpbmVkIGlmIG5vdCB2YWxpZC5cbiAgICovXG4gIHBhcnNlQWRkcmVzcyA9IChhZGRyOnN0cmluZyxcbiAgICBibG9ja2NoYWluSUQ6c3RyaW5nLFxuICAgIGFsaWFzOnN0cmluZyA9IHVuZGVmaW5lZCxcbiAgICBhZGRybGVuOm51bWJlciA9IDIwKTpCdWZmZXIgPT4ge1xuICAgIGNvbnN0IGFiYzpBcnJheTxzdHJpbmc+ID0gYWRkci5zcGxpdCgnLScpO1xuICAgIGlmIChhYmMubGVuZ3RoID09PSAyICYmICgoYWxpYXMgJiYgYWJjWzBdID09PSBhbGlhcykgfHwgKGJsb2NrY2hhaW5JRCAmJiBhYmNbMF0gPT09IGJsb2NrY2hhaW5JRCkpKSB7XG4gICAgICAgIGNvbnN0IGFkZHJidWZmID0gdGhpcy5zdHJpbmdUb0FkZHJlc3MoYWRkcik7XG4gICAgICAgIGlmICgoYWRkcmxlbiAmJiBhZGRyYnVmZi5sZW5ndGggPT09IGFkZHJsZW4pIHx8ICEoYWRkcmxlbikpIHtcbiAgICAgICAgICByZXR1cm4gYWRkcmJ1ZmY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfTtcbn1cbiJdfQ==